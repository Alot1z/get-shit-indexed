/**
 * GSI Artifact Generator Module
 *
 * Generates multiple artifact types from extracted patterns:
 * - Skills: Claude Code skills for reuse
 * - Agents: GSI agent definitions
 * - Logic: TypeScript functions/logic modules
 * - Functions: Reusable function implementations
 * - Features: Feature specifications
 * - Improvements: Command enhancement suggestions
 * - Ideas: Visionary concepts and proposals
 *
 * Phase 38-01: Multi-Type Artifact Generation
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, basename } from 'path';
import { KnowledgePattern, PatternCategory } from './knowledge-base.js';

// Artifact Type System
export type ArtifactType = 
  | 'SKILL' 
  | 'AGENT' 
  | 'LOGIC' 
  | 'FUNCTION' 
  | 'FEATURE' 
  | 'IMPROVEMENT' 
  | 'IDEA';

export interface GeneratedArtifact {
  type: ArtifactType;
  id: string;
  name: string;
  description: string;
  source_pattern: string;
  content: string;
  file_path: string;
  created_at: string;
  metadata: ArtifactMetadata;
}

export interface ArtifactMetadata {
  category: PatternCategory;
  effectiveness: number;
  tags: string[];
  dependencies: string[];
  version: string;
}

// Artifact Generator Interface
export interface ArtifactGenerator {
  type: ArtifactType;
  generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact>;
  getTemplate(pattern: KnowledgePattern): string;
  getFileName(pattern: KnowledgePattern): string;
}

/**
 * Skill Artifact Generator
 * Generates Claude Code skill files from patterns
 */
export class SkillGenerator implements ArtifactGenerator {
  type: ArtifactType = 'SKILL';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'skills', fileName);
    
    mkdirSync(join(outputDir, 'skills'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `skill-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: this.extractTags(pattern),
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    return `# ${pattern.name}

## Purpose
${pattern.description}

## Context
Extracted from: ${pattern.source}

## When to Use
${pattern.whenToUse.map(u => `- ${u}`).join('\n')}

## How to Apply
${pattern.howToApply.map(a => a).join('\n')}

## Variations
${pattern.variations.length > 0 
  ? pattern.variations.map(v => `### ${v.name}\n${v.description}\nContext: ${v.context}`).join('\n\n')
  : 'No variations defined.'}

## Examples
${pattern.examples.map(e => `### ${e.name}\n\`\`\`\n${e.code}\n\`\`\`\n${e.explanation}`).join('\n\n')}

## Effectiveness
${(pattern.effectiveness * 100).toFixed(0)}% (based on ${pattern.uses} uses)

## History
- Extracted: ${new Date().toISOString()}
- Source: ${pattern.source}
- Uses: ${pattern.uses}
- Generated by: GSI Artifact Generator (Phase 38-01)
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const slug = pattern.name.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return `${slug}.md`;
  }

  private extractTags(pattern: KnowledgePattern): string[] {
    const tags = [pattern.category];
    pattern.whenToUse.forEach(u => {
      const words = u.toLowerCase().split(/\s+/);
      words.filter(w => w.length > 4).forEach(w => tags.push(w));
    });
    return [...new Set(tags)].slice(0, 10);
  }
}

/**
 * Agent Artifact Generator
 * Generates GSI agent definitions from patterns
 */
export class AgentGenerator implements ArtifactGenerator {
  type: ArtifactType = 'AGENT';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'agents', fileName);
    
    mkdirSync(join(outputDir, 'agents'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `agent-${pattern.id}`,
      name: this.generateAgentName(pattern),
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: this.extractTags(pattern),
        dependencies: this.inferDependencies(pattern),
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const agentName = this.generateAgentName(pattern);
    const thinkingConfig = this.inferThinkingConfig(pattern);
    
    return `---
name: ${agentName}
description: ${pattern.description}
allowed_tools:
${this.inferTools(pattern).map(t => `  - ${t}`).join('\n')}
thinking_phase:
  mode: ${thinkingConfig.mode}
  servers:
${thinkingConfig.servers.map(s => `    - ${s}`).join('\n')}
  bmad_enabled: ${thinkingConfig.bmad_enabled}
  timeout: ${thinkingConfig.timeout}
  rationale: "${thinkingConfig.rationale}"
---

# ${agentName}

## Objective
${pattern.description}

## Context
This agent was automatically generated from pattern: ${pattern.id}

Source: ${pattern.source}

## Capabilities
${pattern.whenToUse.map(u => `- ${u}`).join('\n')}

## Process

<process>
1. **Initialize**: Load context and verify requirements
${pattern.howToApply.map((a, i) => `${i + 2}. **${this.stepName(a)}**: ${a}`).join('\n')}
${pattern.examples.length > 0 ? `${pattern.howToApply.length + 3}. **Validate**: Verify output matches expected patterns` : ''}
${pattern.howToApply.length + 4}. **Complete**: Report results and update tracking
</process>

## Pattern Application

### When to Apply
${pattern.whenToUse.map(u => `- ${u}`).join('\n')}

### How to Apply
${pattern.howToApply.map(a => `- ${a}`).join('\n')}

## Examples
${pattern.examples.length > 0 
  ? pattern.examples.map(e => `### ${e.name}\n\`\`\`\n${e.code}\n\`\`\`\n${e.explanation}`).join('\n\n')
  : 'No examples available.'}

## Variations
${pattern.variations.length > 0
  ? pattern.variations.map(v => `### ${v.name}\n${v.description}\n- Context: ${v.context}`).join('\n\n')
  : 'No variations defined.'}

## Notes
- Effectiveness: ${(pattern.effectiveness * 100).toFixed(0)}%
- Uses: ${pattern.uses}
- Generated: ${new Date().toISOString()}

<!--
Generated by GSI Artifact Generator (Phase 38-01)
Pattern Source: ${pattern.source}
-->
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const slug = this.generateAgentName(pattern).toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return `gsi-${slug}.md`;
  }

  private generateAgentName(pattern: KnowledgePattern): string {
    // Extract key concept from pattern name
    const words = pattern.name.replace(/Pattern/i, '').trim().split(/\s+/);
    const keyWords = words.filter(w => w.length > 3).slice(0, 3);
    return keyWords.join(' ');
  }

  private inferTools(pattern: KnowledgePattern): string[] {
    // Infer tools based on pattern category and content
    const baseTools = ['Read', 'Edit', 'Write'];
    const categoryTools: Record<PatternCategory, string[]> = {
      'command-patterns': ['Bash', 'Read', 'Edit'],
      'thinking-configs': ['Read', 'Edit'],
      'workflows': ['Read', 'Edit', 'Write', 'Bash'],
      'agents': ['Read', 'Edit', 'Write'],
      'error-handling': ['Read', 'Edit', 'Bash'],
      'optimization': ['Read', 'Edit', 'Bash']
    };
    return [...new Set([...baseTools, ...(categoryTools[pattern.category] || [])])];
  }

  private inferThinkingConfig(pattern: KnowledgePattern): {
    mode: string;
    servers: string[];
    bmad_enabled: boolean;
    timeout: number;
    rationale: string;
  } {
    // Determine thinking complexity based on pattern characteristics
    const complexity = this.assessComplexity(pattern);
    
    if (complexity === 'high') {
      return {
        mode: 'COMPREHENSIVE',
        servers: ['sequential', 'tractatus', 'debug'],
        bmad_enabled: true,
        timeout: 180000,
        rationale: 'High complexity pattern requires comprehensive analysis'
      };
    } else if (complexity === 'medium') {
      return {
        mode: 'STANDARD',
        servers: ['sequential', 'tractatus'],
        bmad_enabled: true,
        timeout: 120000,
        rationale: 'Medium complexity pattern benefits from structured thinking'
      };
    } else {
      return {
        mode: 'LIGHTWEIGHT',
        servers: ['sequential'],
        bmad_enabled: false,
        timeout: 60000,
        rationale: 'Low complexity pattern requires minimal cognitive enhancement'
      };
    }
  }

  private assessComplexity(pattern: KnowledgePattern): 'high' | 'medium' | 'low' {
    const factors = {
      steps: pattern.howToApply.length,
      variations: pattern.variations.length,
      examples: pattern.examples.length,
      uses: pattern.uses
    };
    
    const score = factors.steps * 2 + factors.variations + factors.examples + Math.min(factors.uses, 10);
    
    if (score > 15) return 'high';
    if (score > 8) return 'medium';
    return 'low';
  }

  private stepName(step: string): string {
    // Extract meaningful step name from instruction
    const match = step.match(/^\d+\.\s*(?:\*\*)?([^:*]+)(?:\*\*)?/);
    return match ? match[1].trim() : 'Process';
  }

  private extractTags(pattern: KnowledgePattern): string[] {
    return [pattern.category, 'auto-generated', 'gsi-agent'];
  }

  private inferDependencies(pattern: KnowledgePattern): string[] {
    // Infer dependencies based on pattern category
    const deps: Record<PatternCategory, string[]> = {
      'command-patterns': ['gsi-tools.js'],
      'thinking-configs': ['thinking-orchestrator'],
      'workflows': ['workflow-chainer', 'gsi-tools.js'],
      'agents': ['gsi-tools.js'],
      'error-handling': ['reflection-capture'],
      'optimization': ['pattern-learning']
    };
    return deps[pattern.category] || [];
  }
}

/**
 * Logic Artifact Generator
 * Generates TypeScript logic modules from patterns
 */
export class LogicGenerator implements ArtifactGenerator {
  type: ArtifactType = 'LOGIC';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'logic', fileName);
    
    mkdirSync(join(outputDir, 'logic'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `logic-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['typescript', 'logic', pattern.category],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const moduleName = this.generateModuleName(pattern);
    
    return `/**
 * ${pattern.name}
 * 
 * ${pattern.description}
 * 
 * @module ${moduleName}
 * @generated ${new Date().toISOString()}
 * @pattern ${pattern.id}
 */

/**
 * Pattern context interface
 */
export interface ${this.interfaceName(pattern)}Context {
  ${this.generateContextProperties(pattern)}
}

/**
 * Pattern result interface
 */
export interface ${this.interfaceName(pattern)}Result {
  success: boolean;
  data?: any;
  error?: string;
  metrics?: {
    duration: number;
    steps: number;
  };
}

/**
 * ${pattern.description}
 * 
 * @param context - Execution context
 * @returns Result of pattern application
 * 
 * @example
 * \`\`\`typescript
 * const result = await ${this.functionName(pattern)}({
 *   // context properties
 * });
 * if (result.success) {
 *   console.log('Pattern applied successfully');
 * }
 * \`\`\`
 */
export async function ${this.functionName(pattern)}(
  context: ${this.interfaceName(pattern)}Context
): Promise<${this.interfaceName(pattern)}Result> {
  const startTime = Date.now();
  let stepCount = 0;

  try {
    // Step 1: Initialize and validate
    ${this.generateValidationCode(pattern)}
    stepCount++;

    // Step 2: Apply pattern logic
    ${this.generateLogicCode(pattern)}
    stepCount++;

    // Step 3: Process results
    ${this.generateResultCode(pattern)}
    stepCount++;

    return {
      success: true,
      metrics: {
        duration: Date.now() - startTime,
        steps: stepCount
      }
    };
  } catch (error) {
    return {
      success: false,
      error: error instanceof Error ? error.message : String(error),
      metrics: {
        duration: Date.now() - startTime,
        steps: stepCount
      }
    };
  }
}

/**
 * Validate inputs before pattern application
 */
function validate${this.interfaceName(pattern)}Input(
  context: ${this.interfaceName(pattern)}Context
): void {
  ${this.generateValidationFunction(pattern)}
}

/**
 * Apply core pattern logic
 */
async function apply${this.interfaceName(pattern)}Logic(
  context: ${this.interfaceName(pattern)}Context
): Promise<any> {
  ${this.generateLogicFunction(pattern)}
}

/**
 * Pattern variations
 */
export const ${this.variationsName(pattern)} = {
  ${pattern.variations.map(v => `"${v.name.toLowerCase().replace(/\s+/g, '_')}": {
    description: "${v.description}",
    context: "${v.context}"
  }`).join(',\n  ')}
};

/**
 * Pattern metadata
 */
export const ${this.metadataName(pattern)} = {
  id: "${pattern.id}",
  name: "${pattern.name}",
  category: "${pattern.category}",
  source: "${pattern.source}",
  effectiveness: ${pattern.effectiveness},
  uses: ${pattern.uses},
  generatedAt: "${new Date().toISOString()}"
};

export default {
  ${this.functionName(pattern)},
  ${this.variationsName(pattern)},
  ${this.metadataName(pattern)}
};
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const slug = this.generateModuleName(pattern).toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return `${slug}.ts`;
  }

  private generateModuleName(pattern: KnowledgePattern): string {
    return pattern.name.replace(/[^a-zA-Z0-9]/g, '');
  }

  private interfaceName(pattern: KnowledgePattern): string {
    return this.generateModuleName(pattern);
  }

  private functionName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    return name.split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join('');
  }

  private variationsName(pattern: KnowledgePattern): string {
    return `${this.generateModuleName(pattern).toLowerCase()}Variations`;
  }

  private metadataName(pattern: KnowledgePattern): string {
    return `${this.generateModuleName(pattern).toLowerCase()}Metadata`;
  }

  private generateContextProperties(pattern: KnowledgePattern): string {
    const props = ['input: any;', 'options?: Record<string, any>;'];
    pattern.howToApply.forEach((_, i) => {
      props.push(`step${i + 1}Input?: any;`);
    });
    return props.join('\n  ');
  }

  private generateValidationCode(pattern: KnowledgePattern): string {
    return `validate${this.interfaceName(pattern)}Input(context);`;
  }

  private generateLogicCode(pattern: KnowledgePattern): string {
    return `const result = await apply${this.interfaceName(pattern)}Logic(context);`;
  }

  private generateResultCode(pattern: KnowledgePattern): string {
    return `// Process and return result
    // TODO: Implement result processing based on pattern specifics`;
  }

  private generateValidationFunction(pattern: KnowledgePattern): string {
    return `// Validation logic derived from pattern
  if (!context.input) {
    throw new Error('Input is required');
  }
  // Add pattern-specific validations`;
  }

  private generateLogicFunction(pattern: KnowledgePattern): string {
    return `// Core logic derived from pattern: ${pattern.id}
  ${pattern.howToApply.map((step, i) => `// Step ${i + 1}: ${step}`).join('\n  ')}
  
  // TODO: Implement specific logic based on pattern
  return context.input;`;
  }
}

/**
 * Function Artifact Generator
 * Generates reusable TypeScript functions from patterns
 */
export class FunctionGenerator implements ArtifactGenerator {
  type: ArtifactType = 'FUNCTION';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'functions', fileName);
    
    mkdirSync(join(outputDir, 'functions'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `function-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['typescript', 'function', 'reusable'],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const functionName = this.generateFunctionName(pattern);
    
    return `/**
 * ${pattern.name}
 * 
 * ${pattern.description}
 * 
 * @param input - Input data
 * @param options - Optional configuration
 * @returns Processed result
 * 
 * @example
 * \`\`\`typescript
 * const result = ${functionName}(input, { verbose: true });
 * console.log(result);
 * \`\`\`
 * 
 * @pattern ${pattern.id}
 * @source ${pattern.source}
 * @generated ${new Date().toISOString()}
 */

export interface ${this.optionsInterface(pattern)} {
  verbose?: boolean;
  timeout?: number;
  ${pattern.variations.length > 0 ? 'variation?: string;' : ''}
}

export function ${functionName}(
  input: any,
  options?: ${this.optionsInterface(pattern)}
): any {
  const opts = {
    verbose: false,
    timeout: 30000,
    ...options
  };

  if (opts.verbose) {
    console.log('[${functionName}] Starting with input:', input);
  }

  try {
    ${pattern.howToApply.map((step, i) => `// Step ${i + 1}: ${step}`).join('\n    ')}
    
    // Implementation derived from pattern
    let result = input;
    
    ${pattern.examples.length > 0 ? `// Example reference: ${pattern.examples[0].name}` : ''}
    
    // TODO: Implement specific function logic based on pattern
    
    if (opts.verbose) {
      console.log('[${functionName}] Completed successfully');
    }
    
    return result;
  } catch (error) {
    if (opts.verbose) {
      console.error('[${functionName}] Error:', error);
    }
    throw error;
  }
}

${pattern.variations.length > 0 ? `/**
 * Available variations
 */
export const variations = {
  ${pattern.variations.map(v => `"${v.name.toLowerCase().replace(/\s+/g, '_')}": {
    description: "${v.description}",
    context: "${v.context}"
  }`).join(',\n  ')}
};

export function ${functionName}WithVariation(
  input: any,
  variation: string,
  options?: ${this.optionsInterface(pattern)}
): any {
  if (!variations[variation]) {
    throw new Error(\`Unknown variation: \${variation}\`);
  }
  
  // Apply variation-specific logic
  return ${functionName}(input, { ...options, variation });
}
` : ''}
export default ${functionName};
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = this.generateFunctionName(pattern);
    return `${name}.ts`;
  }

  private generateFunctionName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    return name.split(/\s+/).map((w, i) => 
      i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
    ).join('');
  }

  private optionsInterface(pattern: KnowledgePattern): string {
    return `${this.generateFunctionName(pattern).charAt(0).toUpperCase()}${this.generateFunctionName(pattern).slice(1)}Options`;
  }
}

/**
 * Feature Artifact Generator
 * Generates feature specifications from patterns
 */
export class FeatureGenerator implements ArtifactGenerator {
  type: ArtifactType = 'FEATURE';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'features', fileName);
    
    mkdirSync(join(outputDir, 'features'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `feature-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['feature', 'specification', pattern.category],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const featureName = pattern.name.replace(/Pattern/i, 'Feature').trim();
    
    return `# ${featureName}

## Overview

**Pattern ID**: ${pattern.id}
**Source**: ${pattern.source}
**Effectiveness**: ${(pattern.effectiveness * 100).toFixed(0)}%
**Generated**: ${new Date().toISOString()}

${pattern.description}

## Motivation

This feature was extracted from successful patterns in ${pattern.source}. 
It has been used ${pattern.uses} times with ${(pattern.effectiveness * 100).toFixed(0)}% effectiveness.

## Use Cases

${pattern.whenToUse.map((u, i) => `${i + 1}. ${u}`).join('\n')}

## Specification

### Functional Requirements

${pattern.howToApply.map((a, i) => `#### FR-${String(i + 1).padStart(2, '0')}: ${this.extractRequirement(a)}

${a}

**Acceptance Criteria**:
- [ ] Input validation complete
- [ ] Core logic implemented
- [ ] Output verification passes
`).join('\n')}

### Non-Functional Requirements

#### NFR-01: Performance
- Response time: < 5 seconds for typical inputs
- Memory usage: < 100MB

#### NFR-02: Reliability
- Error handling: Comprehensive
- Recovery: Automatic retry with backoff

#### NFR-03: Maintainability
- Code coverage: > 80%
- Documentation: Complete API docs

## Implementation Plan

### Phase 1: Core Implementation
${pattern.howToApply.slice(0, Math.ceil(pattern.howToApply.length / 2)).map((a, i) => `${i + 1}. ${a}`).join('\n')}

### Phase 2: Integration
${pattern.howToApply.slice(Math.ceil(pattern.howToApply.length / 2)).map((a, i) => `${i + 1}. ${a}`).join('\n')}

### Phase 3: Testing
1. Unit tests for core logic
2. Integration tests for workflows
3. Performance benchmarks

## Examples

${pattern.examples.length > 0 
  ? pattern.examples.map(e => `### ${e.name}

\`\`\`
${e.code}
\`\`\`

${e.explanation}
`).join('\n')
  : 'No examples available.'}

## Variations

${pattern.variations.length > 0
  ? pattern.variations.map(v => `### ${v.name}

${v.description}

**When to use**: ${v.context}
`).join('\n')
  : 'No variations defined.'}

## Dependencies

- Pattern category: ${pattern.category}
- Source file: ${pattern.source}

## Metrics

| Metric | Value |
|--------|-------|
| Effectiveness | ${(pattern.effectiveness * 100).toFixed(0)}% |
| Uses | ${pattern.uses} |
| Steps | ${pattern.howToApply.length} |
| Variations | ${pattern.variations.length} |
| Examples | ${pattern.examples.length} |

## References

- Source Pattern: ${pattern.id}
- Category: ${pattern.category}
- Generated by: GSI Artifact Generator (Phase 38-01)

---

*This feature specification was automatically generated from pattern ${pattern.id}*
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return `${slug}-feature.md`;
  }

  private extractRequirement(step: string): string {
    const match = step.match(/^\d+\.\s*(?:\*\*)?([^:*]+)(?:\*\*)?/);
    return match ? match[1].trim() : 'Requirement';
  }
}

/**
 * Improvement Artifact Generator
 * Generates improvement suggestions from patterns
 */
export class ImprovementGenerator implements ArtifactGenerator {
  type: ArtifactType = 'IMPROVEMENT';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'improvements', fileName);
    
    mkdirSync(join(outputDir, 'improvements'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `improvement-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['improvement', 'enhancement', 'suggestion'],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const improvements = this.generateImprovements(pattern);
    
    return `# Improvement Suggestion: ${pattern.name}

## Overview

**Pattern ID**: ${pattern.id}
**Source**: ${pattern.source}
**Generated**: ${new Date().toISOString()}

Based on analysis of pattern ${pattern.id}, the following improvements are suggested.

## Analysis

### Pattern Metrics
- **Effectiveness**: ${(pattern.effectiveness * 100).toFixed(0)}%
- **Uses**: ${pattern.uses}
- **Category**: ${pattern.category}

### Current State
${pattern.description}

## Suggested Improvements

${improvements.map((imp, i) => `### ${imp.priority} Priority: ${imp.title}

**Rationale**: ${imp.rationale}

**Implementation**:
\`\`\`
${imp.implementation}
\`\`\`

**Expected Impact**: ${imp.impact}

**Effort**: ${imp.effort}

---
`).join('\n')}

## Implementation Roadmap

### Short-term (1-2 weeks)
${improvements.filter(i => i.priority === 'High').map(i => `- [ ] ${i.title}`).join('\n') || '- No high priority items'}

### Medium-term (1 month)
${improvements.filter(i => i.priority === 'Medium').map(i => `- [ ] ${i.title}`).join('\n') || '- No medium priority items'}

### Long-term (2+ months)
${improvements.filter(i => i.priority === 'Low').map(i => `- [ ] ${i.title}`).join('\n') || '- No low priority items'}

## Risk Assessment

| Risk | Likelihood | Impact | Mitigation |
|------|------------|--------|------------|
| Implementation complexity | Medium | Medium | Start with small changes |
| Breaking changes | Low | High | Comprehensive testing |
| Performance regression | Low | Medium | Benchmark before/after |

## Success Criteria

- [ ] All high-priority improvements implemented
- [ ] Test coverage maintained or improved
- [ ] No performance regression
- [ ] Documentation updated

## References

- Source Pattern: ${pattern.id}
- Category: ${pattern.category}
- Generated by: GSI Artifact Generator (Phase 38-01)

---

*This improvement suggestion was automatically generated from pattern ${pattern.id}*
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return `${slug}-improvement.md`;
  }

  private generateImprovements(pattern: KnowledgePattern): Array<{
    priority: 'High' | 'Medium' | 'Low';
    title: string;
    rationale: string;
    implementation: string;
    impact: string;
    effort: string;
  }> {
    const improvements: Array<{
      priority: 'High' | 'Medium' | 'Low';
      title: string;
      rationale: string;
      implementation: string;
      impact: string;
      effort: string;
    }> = [];

    // Effectiveness improvement
    if (pattern.effectiveness < 0.8) {
      improvements.push({
        priority: 'High',
        title: 'Improve Pattern Effectiveness',
        rationale: `Current effectiveness of ${(pattern.effectiveness * 100).toFixed(0)}% indicates room for improvement`,
        implementation: '1. Analyze failure cases\n2. Identify common issues\n3. Refine pattern logic\n4. Add validation steps',
        impact: 'Could improve success rate by 20-30%',
        effort: 'Medium (2-3 days)'
      });
    }

    // Documentation improvement
    if (pattern.examples.length < 2) {
      improvements.push({
        priority: 'Medium',
        title: 'Expand Example Coverage',
        rationale: 'Limited examples may hinder adoption',
        implementation: '1. Document common use cases\n2. Add edge case examples\n3. Include error handling examples',
        impact: 'Improved usability and adoption',
        effort: 'Low (1 day)'
      });
    }

    // Variation expansion
    if (pattern.variations.length < 2) {
      improvements.push({
        priority: 'Medium',
        title: 'Add Pattern Variations',
        rationale: 'More variations increase pattern applicability',
        implementation: '1. Identify common modifications\n2. Document each variation\n3. Create variation tests',
        impact: 'Increased flexibility for users',
        effort: 'Medium (2 days)'
      });
    }

    // Performance optimization
    if (pattern.howToApply.length > 5) {
      improvements.push({
        priority: 'Low',
        title: 'Optimize Step Count',
        rationale: 'Many steps may indicate over-engineering',
        implementation: '1. Review each step\n2. Combine related steps\n3. Remove redundant steps',
        impact: 'Reduced complexity, faster execution',
        effort: 'Low (1 day)'
      });
    }

    return improvements;
  }
}

/**
 * Idea Artifact Generator
 * Generates visionary ideas and concepts from patterns
 */
export class IdeaGenerator implements ArtifactGenerator {
  type: ArtifactType = 'IDEA';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'ideas', fileName);
    
    mkdirSync(join(outputDir, 'ideas'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `idea-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['idea', 'vision', 'concept'],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const ideas = this.generateIdeas(pattern);
    
    return `# Visionary Idea: ${pattern.name}

## Concept Overview

**Pattern ID**: ${pattern.id}
**Source**: ${pattern.source}
**Generated**: ${new Date().toISOString()}

This document explores visionary concepts and innovative ideas derived from pattern analysis.

## Origin Pattern

${pattern.description}

**Metrics**:
- Effectiveness: ${(pattern.effectiveness * 100).toFixed(0)}%
- Uses: ${pattern.uses}
- Category: ${pattern.category}

---

## Generated Ideas

${ideas.map((idea, i) => `### Idea ${i + 1}: ${idea.title}

**Vision**: ${idea.vision}

**Description**:
${idea.description}

**Potential Impact**:
${idea.impact}

**Feasibility**: ${idea.feasibility}

**Next Steps**:
${idea.nextSteps.map((s, j) => `${j + 1}. ${s}`).join('\n')}

**Related Patterns**: ${idea.relatedPatterns.join(', ') || 'None identified'}

---
`).join('\n')}

## Innovation Themes

${this.generateThemes(pattern).map(t => `- **${t.name}**: ${t.description}`).join('\n')}

## Research Questions

${this.generateResearchQuestions(pattern).map((q, i) => `${i + 1}. ${q}`).join('\n')}

## Exploration Roadmap

### Phase 1: Concept Validation (2 weeks)
- Research existing solutions
- Identify key challenges
- Validate assumptions

### Phase 2: Prototype (4 weeks)
- Build minimal viable concept
- Test core functionality
- Gather feedback

### Phase 3: Refinement (4 weeks)
- Iterate on feedback
- Improve implementation
- Document findings

## References

- Source Pattern: ${pattern.id}
- Category: ${pattern.category}
- Generated by: GSI Artifact Generator (Phase 38-01)

---

*This visionary idea document was automatically generated from pattern ${pattern.id}*  
*Human review and refinement recommended before implementation*
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return `${slug}-idea.md`;
  }

  private generateIdeas(pattern: KnowledgePattern): Array<{
    title: string;
    vision: string;
    description: string;
    impact: string;
    feasibility: string;
    nextSteps: string[];
    relatedPatterns: string[];
  }> {
    const ideas: Array<{
      title: string;
      vision: string;
      description: string;
      impact: string;
      feasibility: string;
      nextSteps: string[];
      relatedPatterns: string[];
    }> = [];

    // Generate idea based on pattern category
    switch (pattern.category) {
      case 'command-patterns':
        ideas.push({
          title: 'Self-Evolving Command System',
          vision: 'Commands that automatically improve based on usage patterns',
          description: 'Create a system where commands learn from successful executions and automatically suggest improvements to their own implementation.',
          impact: 'Could dramatically reduce maintenance burden and improve command effectiveness over time',
          feasibility: 'Medium - Requires ML integration and careful safety constraints',
          nextSteps: [
            'Design command telemetry system',
            'Create improvement suggestion engine',
            'Build safety validation layer',
            'Implement gradual rollout mechanism'
          ],
          relatedPatterns: ['optimization', 'error-handling']
        });
        break;

      case 'thinking-configs':
        ideas.push({
          title: 'Adaptive Cognitive Enhancement',
          vision: 'Thinking systems that adapt to user preferences and task types',
          description: 'Build a thinking orchestrator that learns optimal configurations for different users and task types, automatically adjusting complexity.',
          impact: 'Personalized cognitive enhancement that maximizes effectiveness while minimizing token usage',
          feasibility: 'High - Pattern data already exists for learning',
          nextSteps: [
            'Analyze thinking config effectiveness data',
            'Build preference learning model',
            'Create adaptive selection algorithm',
            'Test with diverse task types'
          ],
          relatedPatterns: ['optimization', 'workflows']
        });
        break;

      case 'workflows':
        ideas.push({
          title: 'Autonomous Workflow Composition',
          vision: 'Workflows that compose themselves based on goal descriptions',
          description: 'Enable users to describe high-level goals and have the system automatically compose optimal workflows from available patterns.',
          impact: 'Could reduce workflow creation time by 90% while improving quality',
          feasibility: 'Medium - Requires sophisticated pattern matching and composition',
          nextSteps: [
            'Build workflow pattern library',
            'Create goal-to-pattern matching system',
            'Develop composition algorithm',
            'Add validation and optimization'
          ],
          relatedPatterns: ['command-patterns', 'agents']
        });
        break;

      default:
        ideas.push({
          title: 'Cross-Pattern Synergy Detection',
          vision: 'Automatic detection of synergistic pattern combinations',
          description: 'System that identifies when combining multiple patterns would produce better results than using them individually.',
          impact: 'Could discover new best practices through automated analysis',
          feasibility: 'High - Pattern data available for analysis',
          nextSteps: [
            'Analyze pattern co-occurrence',
            'Identify successful combinations',
            'Build synergy scoring system',
            'Create recommendation engine'
          ],
          relatedPatterns: ['optimization', 'workflows']
        });
    }

    // Add generic innovation idea
    ideas.push({
      title: 'Pattern-Driven Documentation Generation',
      vision: 'Documentation that writes itself from pattern analysis',
      description: 'Automatically generate comprehensive documentation by analyzing how patterns are used across the codebase.',
      impact: 'Always up-to-date documentation with minimal manual effort',
      feasibility: 'High - Pattern extraction already exists',
      nextSteps: [
        'Enhance pattern extraction for doc elements',
        'Build documentation templates',
        'Create doc generation pipeline',
        'Add human review integration'
      ],
      relatedPatterns: [pattern.category]
    });

    return ideas;
  }

  private generateThemes(pattern: KnowledgePattern): Array<{name: string; description: string}> {
    return [
      { name: 'Automation', description: 'Reducing manual intervention through intelligent automation' },
      { name: 'Adaptation', description: 'Systems that learn and adapt from usage patterns' },
      { name: 'Composition', description: 'Building complex solutions from simpler components' },
      { name: 'Optimization', description: 'Continuous improvement through pattern analysis' }
    ];
  }

  private generateResearchQuestions(pattern: KnowledgePattern): string[] {
    return [
      `How can ${pattern.category} patterns be combined for maximum effectiveness?`,
      'What metrics best predict pattern success in different contexts?',
      'Can pattern effectiveness be improved through automated refinement?',
      'What prevents patterns from achieving 100% effectiveness?',
      'How do user preferences affect pattern applicability?'
    ];
  }
}

/**
 * Master Artifact Generator
 * Coordinates all artifact type generators
 */
export class ArtifactGeneratorManager {
  private generators: Map<ArtifactType, ArtifactGenerator>;
  private outputDir: string;

  constructor(outputDir: string) {
    this.outputDir = outputDir;
    this.generators = new Map([
      ['SKILL', new SkillGenerator()],
      ['AGENT', new AgentGenerator()],
      ['LOGIC', new LogicGenerator()],
      ['FUNCTION', new FunctionGenerator()],
      ['FEATURE', new FeatureGenerator()],
      ['IMPROVEMENT', new ImprovementGenerator()],
      ['IDEA', new IdeaGenerator()]
    ]);
  }

  /**
   * Generate a single artifact type from a pattern
   */
  async generate(pattern: KnowledgePattern, type: ArtifactType): Promise<GeneratedArtifact> {
    const generator = this.generators.get(type);
    if (!generator) {
      throw new Error(`Unknown artifact type: ${type}`);
    }
    return generator.generate(pattern, this.outputDir);
  }

  /**
   * Generate all artifact types from a pattern
   */
  async generateAll(pattern: KnowledgePattern): Promise<GeneratedArtifact[]> {
    const artifacts: GeneratedArtifact[] = [];
    const types: ArtifactType[] = ['SKILL', 'AGENT', 'LOGIC', 'FUNCTION', 'FEATURE', 'IMPROVEMENT', 'IDEA'];
    
    for (const type of types) {
      try {
        const artifact = await this.generate(pattern, type);
        artifacts.push(artifact);
      } catch (error) {
        console.error(`Failed to generate ${type} for pattern ${pattern.id}:`, error);
      }
    }
    
    return artifacts;
  }

  /**
   * Generate specific artifact types from a pattern
   */
  async generateTypes(pattern: KnowledgePattern, types: ArtifactType[]): Promise<GeneratedArtifact[]> {
    const artifacts: GeneratedArtifact[] = [];
    
    for (const type of types) {
      try {
        const artifact = await this.generate(pattern, type);
        artifacts.push(artifact);
      } catch (error) {
        console.error(`Failed to generate ${type} for pattern ${pattern.id}:`, error);
      }
    }
    
    return artifacts;
  }

  /**
   * Get list of available artifact types
   */
  getAvailableTypes(): ArtifactType[] {
    return Array.from(this.generators.keys());
  }

  /**
   * Get generator for a specific type
   */
  getGenerator(type: ArtifactType): ArtifactGenerator | undefined {
    return this.generators.get(type);
  }
}

export default ArtifactGeneratorManager;
