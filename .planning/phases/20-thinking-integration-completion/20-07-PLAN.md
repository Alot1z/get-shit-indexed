# Phase 20-07: Cross-Feature Enhancement System

## Objective
Create full mutual enhancement where all GSI features use and enhance each other - thinking uses patterns, patterns use thinking, all use MCP tools optimally.

## Problem Analysis

**Current State:**
- Features exist but are isolated
- Thinking doesn't use pattern learning predictions
- Pattern learning doesn't use thinking for analysis
- MCP tools not optimally coordinated across features

**Solution:**
Create enhancement layer that connects all features for mutual benefit.

## Tasks

### Task 1: Create Feature Registry
```
<task>
Create registry of all GSI features and their capabilities.

1. Create lib/enhancement/feature-registry.js
2. Register all features:
   - thinking: { servers: [sequential, tractatus, debug], triggers: [...] }
   - patterns: { storage: patterns/, capabilities: [predict, learn] }
   - mcp: { servers: [dc, ci, cg], tools: [...] }
   - reflection: { storage: debug-thinking/, triggers: [...] }
   - complexity: { thresholds: {...}, triggers: [...] }
3. Export registry for feature discovery
4. Add feature health checking
</task>

<files>
lib/enhancement/feature-registry.js
</files>

<acceptance>
- All features registered
- Capabilities documented
- Health checking works
</acceptance>
```

### Task 2: Create Enhancement Orchestrator
```
<task>
Create orchestrator that connects features for mutual enhancement.

1. Create lib/enhancement/orchestrator.js
2. Implement enhanceWithFeatures(operation, context):
   - Before operation: Check pattern predictions, thinking recommendations
   - During operation: Use optimal MCP tools based on context
   - After operation: Capture patterns, trigger reflection
3. Implement getEnhancements(operation):
   - Return list of applicable enhancements
4. Add enhancement priority system
5. Export for use across GSI
</task>

<files>
lib/enhancement/orchestrator.js
</files>

<acceptance>
- Orchestrator connects features
- Enhancement works before/during/after
- Priority system works
</acceptance>
```

### Task 3: Connect Thinking to Pattern Learning
```
<task>
Make thinking orchestrator use pattern predictions.

1. Update lib/thinking/orchestrator.js
2. Import pattern-learning predictor
3. In thinkBeforeTool():
   - Query pattern predictor for next operation
   - Include predicted risks in thinking prompt
   - Use predicted optimal approach
4. In thinkAfterTool():
   - Record operation outcome for pattern learning
   - Trigger pattern analysis if threshold met
5. Handle gracefully if patterns unavailable
</task>

<files>
lib/thinking/orchestrator.js
</files>

<acceptance>
- Thinking uses pattern predictions
- Risks included in thinking
- Outcomes recorded for learning
</acceptance>
```

### Task 4: Connect Pattern Learning to Thinking
```
<task>
Make pattern learning use thinking for analysis.

1. Update lib/pattern-learning/recognition.js
2. Import thinking orchestrator
3. In recognizePatterns():
   - Use Tractatus for structure analysis
   - Use Sequential for sequence detection
   - Use Debug for error pattern analysis
4. Add thinking to pattern validation
5. Store thinking-enhanced patterns
</task>

<files>
lib/pattern-learning/recognition.js
</files>

<acceptance>
- Pattern learning uses thinking servers
- Analysis quality improved
- Thinking-enhanced patterns stored
</acceptance>
```

### Task 5: Connect MCP Tool Selection to Context
```
<task>
Make MCP tool selection use all available context.

1. Update lib/thinking/selector.js (or create new module)
2. Import feature registry
3. In selectMode():
   - Check pattern predictions for likely operations
   - Check complexity prediction for load
   - Check available MCP servers
   - Select optimal mode and tools
4. Add MCP server health checking
5. Add fallback chains when servers unavailable
</task>

<files>
lib/thinking/selector.js
lib/enhancement/mcp-coordinator.js
</files>

<acceptance>
- Tool selection uses all context
- Server health checked
- Fallback chains work
</acceptance>
```

### Task 6: Create Enhancement Metrics
```
<task>
Track how much features enhance each other.

1. Create lib/enhancement/metrics.js
2. Track:
   - Thinking enhanced by patterns: count, accuracy
   - Patterns enhanced by thinking: count, quality
   - MCP coordination efficiency: token savings
   - Cross-feature call success rate
3. Implement getEnhancementMetrics()
4. Add to gsi progress enhancement command
5. Store in .planning/enhancement-metrics.json
</task>

<files>
lib/enhancement/metrics.js
.planning/enhancement-metrics.json
</files>

<acceptance>
- All enhancement tracked
- Metrics queryable
- Progress command updated
</acceptance>
```

### Task 7: Document Cross-Feature Architecture
```
<task>
Document the full mutual enhancement architecture.

1. Create .planning/codebase/CROSS-FEATURE-ARCHITECTURE.md
2. Document:
   - Feature registry structure
   - Enhancement flow diagram
   - Cross-feature connections
   - Token savings from coordination
3. Add integration examples
4. Add troubleshooting guide
</task>

<files>
.planning/codebase/CROSS-FEATURE-ARCHITECTURE.md
</files>

<acceptance>
- Architecture documented
- Flow diagram created
- Examples provided
</acceptance>
```

## Verification

**Must Have:**
- [ ] Feature registry works
- [ ] Enhancement orchestrator works
- [ ] Thinking uses patterns
- [ ] Patterns use thinking
- [ ] MCP coordination optimal
- [ ] Metrics tracked

## Estimated Duration
15-18 minutes (7 tasks)

## Dependencies
- Phase 20-02b (Thinking Orchestrator)
- Phase 22-01 (Pattern Learning)
- Phase 14 (MCP Tool Optimization)
