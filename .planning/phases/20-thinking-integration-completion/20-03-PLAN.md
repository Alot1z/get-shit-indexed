# Phase 20-03: PostToolUse Reflection System

## Objective
Create a reflection system that captures learnings, errors, and patterns after tool execution using debug-thinking knowledge graph.

## Problem Analysis

**Current State:**
- hooks.json has posttooluse.reflection-capture configuration but no implementation
- No learning capture after tool operations
- Errors are logged but not analyzed
- Successful patterns not captured for future use

**Root Cause:**
PostToolUse hooks were planned but never implemented. We need to create the reflection capture system that stores learnings in the debug-thinking knowledge graph.

## Tasks

### Task 1: Design Reflection Schema
```
<task>
Design the schema for reflection data that will be captured and stored.

1. Create lib/reflection/schema.js
2. Define reflection types:
   - SUCCESS: Operation completed successfully
   - ERROR: Operation failed
   - PARTIAL: Operation partially succeeded
   - INSIGHT: New understanding discovered
3. Define reflection structure:
   - timestamp, toolName, operation
   - input context, output result
   - thinkingBefore, thinkingAfter
   - patterns, insights, recommendations
4. Add validation for reflection data
5. Export schema for use by capture system
</task>

<files>
lib/reflection/schema.js
</files>

<acceptance>
- Reflection schema defined
- All types covered
- Validation implemented
- Exported for use
</acceptance>
```

### Task 2: Create Reflection Capture Engine
```
<task>
Create the reflection capture engine that analyzes tool execution results.

1. Create lib/reflection/capture.js
2. Implement capture(toolName, context, result) function
3. Analyze result for:
   - Success/failure status
   - Unexpected outputs
   - Performance characteristics
   - Pattern matches
4. Generate reflection object
5. Add error detection and classification
6. Export for hook integration
</task>

<files>
lib/reflection/capture.js
</files>

<acceptance>
- Capture engine created
- Result analysis works
- Reflection generation functional
- Error classification implemented
</acceptance>
```

### Task 3: Implement Debug-Thinking Integration
```
<task>
Connect reflection capture to debug-thinking knowledge graph.

1. Create lib/reflection/debug-integration.js
2. Import debug-thinking MCP tool
3. Implement storeReflection(reflection) function:
   - Create observation node in debug graph
   - Link to related problem/hypothesis nodes
   - Add metadata (tool, timestamp, score)
4. Implement queryRelatedProblems(pattern) function
5. Implement linkToHypothesis(observationId, hypothesisId) function
6. Add error handling (non-blocking)
</task>

<files>
lib/reflection/debug-integration.js
</files>

<acceptance>
- Debug-thinking integration created
- Observations stored in knowledge graph
- Links created between nodes
- Querying works
</acceptance>
```

### Task 4: Create Pattern Extraction System
```
<task>
Create a system that extracts reusable patterns from tool execution results.

1. Create lib/reflection/patterns.js
2. Implement extractPatterns(reflection) function:
   - Identify recurring sequences
   - Extract successful approaches
   - Detect anti-patterns
3. Define pattern types:
   - SEQUENCE: Ordered operation patterns
   - CONDITIONAL: If-then patterns
   - ERROR_RECOVERY: Error handling patterns
4. Implement pattern matching against history
5. Store patterns in .planning/patterns.json
</task>

<files>
lib/reflection/patterns.js
.planning/patterns.json
</files>

<acceptance>
- Pattern extraction implemented
- All pattern types defined
- Pattern matching works
- Patterns stored for reuse
</acceptance>
```

### Task 5: Implement Insight Generation
```
<task>
Create insight generation that produces actionable recommendations from reflections.

1. Create lib/reflection/insights.js
2. Implement generateInsights(reflection) function:
   - Analyze success factors
   - Identify improvement opportunities
   - Generate recommendations
3. Define insight types:
   - OPTIMIZATION: Performance improvement
   - SAFETY: Error prevention
   - CLARITY: Understanding improvement
4. Rank insights by impact and feasibility
5. Store insights for future reference
</task>

<files>
lib/reflection/insights.js
</files>

<acceptance>
- Insight generation implemented
- All insight types defined
- Ranking works correctly
- Insights stored for reference
</acceptance>
```

### Task 6: Create Reflection Hook
```
<task>
Create the PostToolUse reflection hook that captures learnings after every tool execution.

1. Create hooks/post-tool-use/reflection-capture.js
2. Import reflection capture engine
3. Import debug-thinking integration
4. Implement run(toolName, context, result) function:
   - Capture reflection data
   - Store in debug-thinking graph
   - Extract patterns
   - Generate insights
5. Add trigger conditions (errors, significant, thinking)
6. Add error handling (non-blocking, always succeed)
</task>

<files>
hooks/post-tool-use/reflection-capture.js
</files>

<acceptance>
- Reflection hook created
- Captures data after tool execution
- Stores in knowledge graph
- Non-blocking error handling
</acceptance>
```

### Task 7: Create Reflection Viewer
```
<task>
Create a CLI command to view reflection history and insights.

1. Add reflection command to gsi-tools.js
2. Implement subcommands:
   - gsi reflection list: Show recent reflections
   - gsi reflection patterns: Show extracted patterns
   - gsi reflection insights: Show generated insights
   - gsi reflection graph: Visualize debug-thinking graph
3. Add filtering by tool, date, type
4. Add export to JSON/Markdown
</task>

<files>
bin/gsi-tools.js (update)
</files>

<acceptance>
- Reflection CLI command added
- All subcommands work
- Filtering functional
- Export works
</acceptance>
```

## Verification

**Must Have:**
- [ ] Reflection capture works after tool execution
- [ ] Reflections stored in debug-thinking graph
- [ ] Patterns extracted from reflections
- [ ] Insights generated from patterns
- [ ] Non-blocking error handling

**Nice to Have:**
- [ ] Reflection CLI viewer
- [ ] Pattern visualization
- [ ] Insight export

## Estimated Duration
15-20 minutes (7 tasks with debug-thinking integration)

## Dependencies
- Phase 20-01 (Hook Registration) - hooks must be registered
- Phase 20-02 (PreToolUse Thinking) - thinking results for comparison
- Debug-thinking MCP server - for knowledge graph storage
