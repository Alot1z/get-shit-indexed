---
phase: 31
plan: 05
title: Memory Management
wave: 2
depends_on: [31-04]
files_modified:
  - lib/gsi-core/memory/garbage-collector.ts
  - lib/gsi-core/memory/memory-monitor.ts
autonomous: true
must_haves:
  truths:
    - Memory leaks prevented
    - Usage monitored
    - Cleanup automatic
  artifacts:
    - lib/gsi-core/memory/garbage-collector.ts:100
    - lib/gsi-core/memory/memory-monitor.ts:80
---

# 31-05: Memory Management

## Objective
Implement memory management to prevent leaks and optimize usage.

## Tasks

### Task 1: Garbage Collector Helper
**File**: `lib/gsi-core/memory/garbage-collector.ts`
**Lines**: ~100

```typescript
export interface Cleanable {
  cleanup(): void | Promise<void>;
}

export class GarbageCollector {
  private registry: FinalizationRegistry<Cleanable>;
  private cleanupQueue: Cleanable[] = [];

  constructor() {
    this.registry = new FinalizationRegistry((heldValue: Cleanable) => {
      this.cleanupQueue.push(heldValue);
    });
  }

  /**
   * Register object for automatic cleanup
   */
  register(target: Cleanable, token?: object): void {
    this.registry.register(target, target, token);
  }

  /**
   * Unregister from automatic cleanup
   */
  unregister(token: object): void {
    this.registry.unregister(token);
  }

  /**
   * Process cleanup queue
   */
  async processQueue(): Promise<void> {
    const toClean = [...this.cleanupQueue];
    this.cleanupQueue = [];

    await Promise.all(toClean.map(item => {
      try {
        return Promise.resolve(item.cleanup());
      } catch {
        // Ignore cleanup errors
      }
    }));
  }

  /**
   * Force cleanup of all registered items
   */
  async forceCleanup(): Promise<void> {
    await this.processQueue();
    if (global.gc) {
      global.gc();
    }
  }
}
```

### Task 2: Memory Monitor
**File**: `lib/gsi-core/memory/memory-monitor.ts`
**Lines**: ~80

```typescript
export interface MemoryStats {
  heapUsed: number;
  heapTotal: number;
  external: number;
  rss: number;
}

export class MemoryMonitor {
  private threshold: number;
  private onWarning?: (stats: MemoryStats) => void;

  constructor(thresholdMB: number = 500) {
    this.threshold = thresholdMB * 1024 * 1024;
  }

  /**
   * Get current memory stats
   */
  getStats(): MemoryStats {
    const usage = process.memoryUsage();
    return {
      heapUsed: usage.heapUsed,
      heapTotal: usage.heapTotal,
      external: usage.external,
      rss: usage.rss
    };
  }

  /**
   * Check if memory usage exceeds threshold
   */
  checkThreshold(): boolean {
    const stats = this.getStats();
    return stats.heapUsed > this.threshold;
  }

  /**
   * Set warning callback
   */
  setWarningCallback(callback: (stats: MemoryStats) => void): void {
    this.onWarning = callback;
  }

  /**
   * Start periodic monitoring
   */
  startMonitoring(intervalMs: number = 60000): NodeJS.Timeout {
    return setInterval(() => {
      if (this.checkThreshold() && this.onWarning) {
        this.onWarning(this.getStats());
      }
    }, intervalMs);
  }

  /**
   * Format bytes to human readable
   */
  static formatBytes(bytes: number): string {
    const mb = bytes / (1024 * 1024);
    return `${mb.toFixed(2)} MB`;
  }
}
```

## Output
- Garbage collector helper
- Memory monitor with thresholds
- Automatic cleanup system

**Next**: 31-06 - Profiling Tools
