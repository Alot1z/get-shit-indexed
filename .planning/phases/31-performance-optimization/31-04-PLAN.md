---
phase: 31
plan: 04
title: Lazy Loading
wave: 2
depends_on: [31-02, 31-03]
files_modified:
  - lib/gsi-core/loader/lazy-loader.ts
  - lib/gsi-core/loader/module-cache.ts
autonomous: true
must_haves:
  truths:
    - Modules loaded on demand
    - Cache prevents re-loading
    - Memory usage optimized
  artifacts:
    - lib/gsi-core/loader/lazy-loader.ts:120
    - lib/gsi-core/loader/module-cache.ts:80
---

# 31-04: Lazy Loading

## Objective
Implement lazy loading for skills and modules to reduce startup time.

## Tasks

### Task 1: Lazy Loader
**File**: `lib/gsi-core/loader/lazy-loader.ts`
**Lines**: ~120

```typescript
import { ModuleCache } from './module-cache.js';

export interface LazyModule<T> {
  loaded: boolean;
  module: T | null;
  loader: () => Promise<T>;
}

export class LazyLoader {
  private cache: ModuleCache;
  private modules: Map<string, LazyModule<unknown>> = new Map();

  constructor() {
    this.cache = new ModuleCache();
  }

  /**
   * Register a module for lazy loading
   */
  register<T>(name: string, loader: () => Promise<T>): void {
    this.modules.set(name, {
      loaded: false,
      module: null,
      loader: loader as () => Promise<unknown>
    });
  }

  /**
   * Load a module on demand
   */
  async load<T>(name: string): Promise<T> {
    // Check cache first
    const cached = this.cache.get<T>(name);
    if (cached) return cached;

    // Get lazy module
    const lazy = this.modules.get(name);
    if (!lazy) {
      throw new Error(`Module not registered: ${name}`);
    }

    // Load if not already loaded
    if (!lazy.loaded) {
      lazy.module = await lazy.loader();
      lazy.loaded = true;
    }

    // Cache and return
    this.cache.set(name, lazy.module);
    return lazy.module as T;
  }

  /**
   * Preload modules in parallel
   */
  async preload(names: string[]): Promise<void> {
    await Promise.all(names.map(name => this.load(name)));
  }

  /**
   * Check if module is loaded
   */
  isLoaded(name: string): boolean {
    const lazy = this.modules.get(name);
    return lazy?.loaded ?? false;
  }

  /**
   * Unload a module to free memory
   */
  unload(name: string): boolean {
    const lazy = this.modules.get(name);
    if (lazy) {
      lazy.loaded = false;
      lazy.module = null;
      this.cache.delete(name);
      return true;
    }
    return false;
  }

  /**
   * Get memory usage statistics
   */
  getStats(): { registered: number; loaded: number; cached: number } {
    let loaded = 0;
    for (const lazy of this.modules.values()) {
      if (lazy.loaded) loaded++;
    }
    return {
      registered: this.modules.size,
      loaded,
      cached: this.cache.size()
    };
  }
}
```

### Task 2: Module Cache
**File**: `lib/gsi-core/loader/module-cache.ts`
**Lines**: ~80

```typescript
export class ModuleCache {
  private cache: Map<string, { module: unknown; timestamp: number }> = new Map();
  private maxSize: number = 50;
  private ttl: number = 30 * 60 * 1000; // 30 minutes

  /**
   * Get module from cache
   */
  get<T>(name: string): T | null {
    const entry = this.cache.get(name);
    if (!entry) return null;

    // Check TTL
    if (Date.now() - entry.timestamp > this.ttl) {
      this.cache.delete(name);
      return null;
    }

    return entry.module as T;
  }

  /**
   * Set module in cache
   */
  set(name: string, module: unknown): void {
    // Evict oldest if at max size
    if (this.cache.size >= this.maxSize) {
      const firstKey = this.cache.keys().next().value;
      if (firstKey) this.cache.delete(firstKey);
    }

    this.cache.set(name, { module, timestamp: Date.now() });
  }

  /**
   * Delete from cache
   */
  delete(name: string): boolean {
    return this.cache.delete(name);
  }

  /**
   * Get cache size
   */
  size(): number {
    return this.cache.size;
  }

  /**
   * Clear cache
   */
  clear(): void {
    this.cache.clear();
  }
}
```

## Output
- Lazy loader with on-demand loading
- Module cache with TTL and size limits
- 50%+ memory reduction target

**Next**: 31-05 - Memory Management
