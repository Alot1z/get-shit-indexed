---
phase: 31
plan: 03
title: Parallel Processing
wave: 1
depends_on: [31-01]
files_modified:
  - lib/gsi-core/executor/parallel-executor.ts
  - lib/gsi-core/executor/task-queue.ts
autonomous: true
must_haves:
  truths:
    - Tasks execute in parallel
    - Resource limits enforced
    - Results aggregated correctly
  artifacts:
    - lib/gsi-core/executor/parallel-executor.ts:150
    - lib/gsi-core/executor/task-queue.ts:100
  key_links:
    - from: parallel-executor.ts:executeAll()
      to: task-queue.ts
      via: queue.dequeue()
---

# 31-03: Parallel Processing

## Objective
Implement parallel task execution for improved performance.

## Tasks

### Task 1: Parallel Executor
**File**: `lib/gsi-core/executor/parallel-executor.ts`
**Lines**: ~150

```typescript
import { TaskQueue, Task, TaskResult } from './task-queue.js';

export interface ParallelConfig {
  maxConcurrency: number;
  timeout: number;
  retryCount: number;
}

export class ParallelExecutor {
  private queue: TaskQueue;
  private config: ParallelConfig;

  constructor(config: Partial<ParallelConfig> = {}) {
    this.config = {
      maxConcurrency: config.maxConcurrency ?? 5,
      timeout: config.timeout ?? 30000,
      retryCount: config.retryCount ?? 2
    };
    this.queue = new TaskQueue();
  }

  /**
   * Add task to execution queue
   */
  addTask(task: Task): void {
    this.queue.enqueue(task);
  }

  /**
   * Execute all tasks in parallel with concurrency limit
   */
  async executeAll(): Promise<TaskResult[]> {
    const results: TaskResult[] = [];
    const executing: Promise<void>[] = [];

    while (!this.queue.isEmpty()) {
      // Wait if at max concurrency
      if (executing.length >= this.config.maxConcurrency) {
        await Promise.race(executing);
      }

      // Start next task
      const task = this.queue.dequeue();
      if (task) {
        const promise = this.executeTask(task)
          .then(result => {
            results.push(result);
            // Remove from executing array
            const index = executing.indexOf(promise);
            if (index >= 0) executing.splice(index, 1);
          });
        executing.push(promise);
      }
    }

    // Wait for all remaining tasks
    await Promise.all(executing);
    return results;
  }

  /**
   * Execute single task with retry logic
   */
  private async executeTask(task: Task): Promise<TaskResult> {
    let lastError: Error | null = null;

    for (let attempt = 0; attempt <= this.config.retryCount; attempt++) {
      try {
        const result = await Promise.race([
          task.execute(),
          this.timeoutPromise()
        ]);
        return { task, success: true, result };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));
        if (attempt < this.config.retryCount) {
          await this.delay(1000 * attempt); // Exponential backoff
        }
      }
    }

    return { task, success: false, error: lastError };
  }

  private timeoutPromise(): Promise<never> {
    return new Promise((_, reject) => {
      setTimeout(() => reject(new Error('Task timeout')), this.config.timeout);
    });
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Task 2: Task Queue
**File**: `lib/gsi-core/executor/task-queue.ts`
**Lines**: ~100

```typescript
export interface Task {
  id: string;
  priority: number;
  execute: () => Promise<unknown>;
}

export interface TaskResult {
  task: Task;
  success: boolean;
  result?: unknown;
  error?: Error | null;
}

export class TaskQueue {
  private queue: Task[] = [];

  /**
   * Add task to queue (sorted by priority)
   */
  enqueue(task: Task): void {
    this.queue.push(task);
    this.queue.sort((a, b) => b.priority - a.priority);
  }

  /**
   * Get next highest priority task
   */
  dequeue(): Task | undefined {
    return this.queue.shift();
  }

  /**
   * Check if queue is empty
   */
  isEmpty(): boolean {
    return this.queue.length === 0;
  }

  /**
   * Get queue size
   */
  size(): number {
    return this.queue.length;
  }

  /**
   * Clear queue
   */
  clear(): void {
    this.queue = [];
  }

  /**
   * Peek at next task without removing
   */
  peek(): Task | undefined {
    return this.queue[0];
  }
}
```

## Output
- Parallel executor with concurrency control
- Priority-based task queue
- Retry logic with exponential backoff

**Next**: 31-04 - Lazy Loading
