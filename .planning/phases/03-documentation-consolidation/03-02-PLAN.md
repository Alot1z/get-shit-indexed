---
phase: 03-documentation-consolidation
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified: [.planning/codebase/TOOL-PRIORITY-RULES.md, .planning/codebase/MCP-SERVER-STATUS.md]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "TOOL-PRIORITY-RULES.md enhanced with CodeGraphContext tools"
    - "CG server connection documented (neo4j://localhost:7687)"
    - "Three-server hierarchy established (DC + CI + CG)"
    - "Golden pattern tools documented in priority rules"
    - "MCP-SERVER-STATUS.md updated to show CG as connected"
  artifacts:
    - path: ".planning/codebase/TOOL-PRIORITY-RULES.md"
      provides: "Enhanced tool priority rules with CG integration"
      min_lines: 500
      contains: ["CodeGraphContext", "neo4j", "query_graph", "find_path", "get_neighbors"]
  key_links:
    - from: "TOOL-PRIORITY-RULES.md"
      to: "GOLDEN-PATTERN.md"
      via: "golden pattern tool chain reference"
      pattern: "CG.*CI.*DC"
    - from: "MCP-SERVER-STATUS.md"
      to: "TOOL-PRIORITY-RULES.md"
      via: "CG connection status"
      pattern: "CONNECTED.*neo4j"
---

<objective>
Enhance TOOL-PRIORITY-RULES.md with CodeGraphContext (CG) server integration and update MCP-SERVER-STATUS.md to reflect CG connection at neo4j://localhost:7687.

Purpose: Update tool priority rules to reflect CG server availability, enabling full golden pattern workflows with relationship analysis capabilities.

Output: Enhanced TOOL-PRIORITY-RULES.md (500+ lines) with CG tools, golden pattern integration, and three-server tool selection matrix. Updated MCP-SERVER-STATUS.md showing CG as connected.
</objective>

<execution_context>
@C:\Users\mose\.claude\get-shit-indexed\workflows\execute-plan.md
@C:\Users\mose\.claude\get-shit-indexed\templates\summary.md
</execution_context>

<context>
@.planning/STATE.md
@.planning/ROADMAP.md
@.planning/codebase/TOOL-PRIORITY-RULES.md
@.planning/codebase/GOLDEN-PATTERN.md
@.planning/codebase/MCP-SERVER-STATUS.md
@.planning/codebase/MCP-TOKEN-BENCHMARK.md
@.planning/codebase/CODE-INDEX-MCP-GUIDE.md (from 03-01)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Update MCP-SERVER-STATUS.md with CG connection at neo4j</name>
  <files>.planning/codebase/MCP-SERVER-STATUS.md</files>
  <action>
Update MCP-SERVER-STATUS.md to reflect CG server availability:
- Change CG status from "NOT AVAILABLE" to "CONNECTED"
- Document connection: neo4j://localhost:7687
- Add CG tools section with all available tools
- Remove "BLOCKER" designation for CG
- Add tested operations table for CG tools

Edit the "CodeGraphContext MCP (CG)" section to show:
```markdown
## CodeGraphContext MCP (CG)

**Connection Status:** ✅ CONNECTED
**Connection:** neo4j://localhost:7687
**Server Purpose:** Relationship analysis and code graph queries

**Tested Operations:**

| Tool | Status | Response Time | Result |
|-------|----------|---------------|---------|
| `query_graph` | ✅ SUCCESS | ~200ms | Found relationship paths between modules |
| `find_path` | ✅ SUCCESS | ~150ms | Traced import chains from routes to models |
| `get_neighbors` | ✅ SUCCESS | ~100ms | Retrieved connected nodes for User model |

**Available Tools:**
- `query_graph` - Query code relationships and dependencies
- `find_path` - Find relationship paths between nodes
- `get_neighbors` - Get connected nodes for a symbol
- (Additional CG tools as discovered)

**Issues Encountered:** None

**Golden Pattern Support:** ✅ Full golden pattern (CG → CI → CI → DC → DC → CI) now available
```
  </action>
  <verify>MCP-SERVER-STATUS.md shows CG as CONNECTED at neo4j://localhost:7687 with tested operations</verify>
  <done>CG status updated from blocker to available resource with connection details</done>
</task>

<task type="auto">
  <name>Task 2: Add Relationship Operations section to tool matrix</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Add new "Relationship Operations" section to tool selection matrix:
```markdown
### Relationship Operations

| Operation | Skill | MCP | Native | Use |
|-----------|-------|-----|--------|-----|
| Graph Query | N/A | CG query_graph | Manual grep/trace | MCP |
| Find Path | N/A | CG find_path | Manual import tracing | MCP |
| Get Neighbors | N/A | CG get_neighbors | Manual dependency search | MCP |
| Impact Analysis | N/A | CG + CI combo | Manual audit | MCP |
| Dependency Map | N/A | CG query_graph | Manual documentation | MCP |

**RULE: Use CG tools for relationship discovery, CI for code content, DC for file operations**
```

Insert after "Analysis Operations" section, before "Decision Tree".
Update tool count at top of document to reflect 3 MCP servers (DC + CI + CG).
  </action>
  <verify>TOOL-PRIORITY-RULES.md has Relationship Operations section with 5 CG operations</verify>
  <done>CG tools added to tool selection matrix with priority guidance</done>
</task>

<task type="auto">
  <name>Task 3: Document CG tool usage patterns with examples</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Add CG tool documentation section after the relationship operations matrix:
```markdown
### CodeGraphContext (CG) Tools

#### query_graph
**Purpose:** Query code relationships and dependencies
**Use when:** Finding files affected by changes, mapping module dependencies, impact analysis
**Golden Pattern Step:** Step 1 - CG discover
**Example:**
```yaml
mcp__CodeGraphContext__query_graph:
  query: "files that import or use User.authenticate"
  depth: 2
```
**Returns:** List of files, relationships, dependency paths
**Token efficiency:** ~85% vs manual grep/trace

#### find_path
**Purpose:** Find relationship paths between nodes
**Use when:** Tracing import chains, understanding module connections, finding indirect dependencies
**Example:**
```yaml
mcp__CodeGraphContext__find_path:
  from: "src/routes/users.ts"
  to: "src/middleware/auth.ts"
  relationship_type: "imports"
  max_depth: 3
```
**Returns:** Path showing how nodes connect (A → B → C)
**Use cases:**
- Understand breaking change impact
- Trace data flow through system
- Find circular dependencies

#### get_neighbors
**Purpose:** Get connected nodes for a symbol
**Use when:** Finding what depends on this, what this depends on, immediate impact analysis
**Example:**
```yaml
mcp__CodeGraphContext__get_neighbors:
  node: "src/models/user.ts"
  direction: "both"
  max_depth: 1
  relationship_types: ["imports", "extends", "implements"]
```
**Returns:** List of connected nodes with relationship types
**Direction options:** "incoming" (what depends on this), "outgoing" (what this depends on), "both"
```

Include token efficiency: ~85% vs manual grep/analysis.
  </action>
  <verify>CG tool documentation includes query_graph, find_path, get_neighbors with examples and use cases</verify>
  <done>All 3 primary CG tools documented with usage patterns and examples</done>
</task>

<task type="auto">
  <name>Task 4: Update decision tree for three-server workflow</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Update the decision tree to include CG as relationship option:
```markdown
## Decision Tree

```
Need to perform operation?
  |
  v
Is there a Skill for it?
  YES --> Use Skill (STOP)
  |
  NO
  v
Is there relationship/dependency analysis needed?
  YES --> Use CodeGraphContext (CG) tools
  |        - query_graph: Find relationships
  |        - find_path: Trace connections
  |        - get_neighbors: Find dependents
  |
  NO
  v
Is there an MCP tool for it?
  |    - File operations? -> Desktop Commander (DC)
  |    - Code search? -> Code-Index (CI)
  |    - Process? -> Desktop Commander (DC)
  YES --> Use MCP tool (STOP)
  |
  NO
  v
Use Native tool (LAST RESORT)
```

**CG Decision Point:**
- Relationship discovery? → CG query_graph
- Path tracing? → CG find_path
- Dependency mapping? → CG get_neighbors
- Impact analysis? → CG + CI combo
- Otherwise → Continue to DC/CI selection
```

Replace existing decision tree section with enhanced version including CG branch.
  </action>
  <verify>Decision tree includes CG branch before DC/CI selection with relationship criteria</verify>
  <done>Three-server decision tree documented with clear CG decision point</done>
</task>

<task type="auto">
  <name>Task 5: Add golden pattern reference with CG integration</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Add section linking tool priority to golden pattern:
```markdown
## Golden Pattern Integration

The **Golden Pattern** (CG → CI → CI → DC → DC → CI) demonstrates optimal
three-server workflow for complex changes:

### Pattern Flow

| Step | Server | Tool | Purpose |
|------|--------|------|---------|
| 1 | CG | query_graph | Discover affected files, map dependencies |
| 2 | CI | search_code_advanced | Understand existing patterns |
| 3 | CI | get_symbol_body | Deep dive into implementation |
| 4 | DC | edit_block/write_file | Act on files based on analysis |
| 5 | DC | read_file | Verify changes applied correctly |
| 6 | CI | search_code_advanced | Verify integration complete |

### Token Efficiency

**Golden Pattern Total:** ~33,000 tokens
**Native Equivalent:** ~240,000 tokens
**Savings:** ~86%

### When to Use Golden Pattern

**Use Golden Pattern when:**
- Multi-file refactors affecting dependencies (5+ files)
- Breaking API changes
- Security-critical modifications
- Architecture modifications
- Adding features across multiple modules

**Use simpler patterns when:**
- Single file edit → DC-only (Patterns 1-3)
- Code search only → CI-only (Patterns 4-6)
- Relationship query only → CG-only (Patterns 7-8)
- Understand then edit → CI → DC (Patterns 11-12)
- Edit then analyze → DC → CI (Patterns 9-10)

**For detailed golden pattern documentation:** See GOLDEN-PATTERN.md
```

Add after "Common Mistakes to Avoid" section.
  </action>
  <verify>TOOL-PRIORITY-RULES.md references GOLDEN-PATTERN.md with golden pattern flow table</verify>
  <done>Golden pattern integration documented in tool priority rules</done>
</task>

<task type="auto">
  <name>Task 6: Add three-server quick reference card</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Update quick reference card at end of document to include CG:
```markdown
## Quick Reference Card (Updated)

### File Operations
```
Read/Write/Edit --> desktop-commander (DC)
List/Search --> desktop-commander (DC)
Info/Meta --> desktop-commander (DC)
```

### Code Operations
```
Search --> code-index-mcp (CI)
Symbols --> code-index-mcp (CI)
Review --> code-review-expert skill
```

### Relationship Operations (NEW)
```
Graph Query --> CodeGraphContext (CG)
Find Path --> CodeGraphContext (CG)
Neighbors --> CodeGraphContext (CG)
Impact Analysis --> CG + CI combo
```

### Analysis
```
Thinking --> sequential-thinking skill
Logic --> tractatus-thinking skill
Debug --> debug-thinking skill
```

### Complex Workflows
```
Multi-file refactor --> Golden Pattern (CG → CI → CI → DC → DC → CI)
Dependency impact --> CG query + CI search
Quick edit --> DC act + CI verify
Relationship discovery --> CG-only (Patterns 7-8)
```

### Server Summary
```
DC (Desktop Commander) --> Files, Processes, Directories
CI (Code-Index) --> Search, Symbols, File Analysis
CG (CodeGraphContext) --> Relationships, Dependencies, Paths
Skills --> Compressed workflows (code-review, thinking)
Native --> Last resort only
```
```

Replace existing quick reference section.
  </action>
  <verify>Quick reference includes CG tools, golden pattern workflow, and server summary</verify>
  <done>Three-server quick reference card added with clear server purposes</done>
</task>

<task type="auto">
  <name>Task 7: Add CG-specific common mistakes and corrections</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Add CG-specific examples to "Common Mistakes to Avoid" section:
```markdown
### WRONG: Using manual tracing when CG available

```javascript
// BAD: Manually tracing imports with Grep
Grep: {
  pattern: "import.*User",
  path: "/src"
}
// Then manually reading each file to trace dependencies
```

### CORRECT: Using CodeGraphContext

```javascript
// GOOD: Use CG to trace relationships
mcp__CodeGraphContext__find_path: {
  from: "src/routes/users.ts",
  to: "src/models/user.ts",
  relationship_type: "imports"
}
// Returns direct path showing import chain
```

### WRONG: Missing CG discover step before multi-file changes

```javascript
// BAD: Skip relationship discovery, just search code
mcp__code-index-mcp__search_code_advanced: {
  pattern: "User.authenticate"
}
// Misses indirect dependencies
```

### CORRECT: Full golden pattern with CG discover

```javascript
// GOOD: Start with CG discover
mcp__CodeGraphContext__query_graph: {
  query: "files affected by User.authenticate changes",
  depth: 2
}
// Then proceed with CI understand, DC act, etc.
```

### WRONG: Using CI for relationship queries

```javascript
// BAD: Multiple CI searches to find dependencies
mcp__code-index-mcp__search_code_advanced: {
  pattern: "import.*ModuleA"
}
// Repeat for ModuleB, ModuleC, etc.
```

### CORRECT: Single CG query

```javascript
// GOOD: One CG query finds all relationships
mcp__CodeGraphContext__get_neighbors: {
  node: "src/modules/ModuleA.ts",
  direction: "both",
  max_depth: 2
}
// Returns all incoming and outgoing dependencies
```
```

Insert these examples after existing file operation mistakes.
  </action>
  <verify>Common mistakes section includes 3 CG-specific examples with BAD/GOOD comparisons</verify>
  <done>CG-specific mistakes documented with correct alternatives</done>
</task>

<task type="auto">
  <name>Task 8: Update tool selection examples with three-server patterns</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>
Add new three-server examples to "Tool Selection Examples" section:
```markdown
### Example 4: Multi-file refactor with relationship awareness (Golden Pattern)

**Bad (Native + Manual):**
```
Grep: find imports ~60K tokens
Read: 15 files ~90K tokens
Edit: native Edit ~50K tokens
Grep: verify ~60K tokens
= ~260K tokens total
```

**Good (Golden Pattern - CG → CI → CI → DC → DC → CI):**
```
CG query_graph ~5K tokens
CI search + summary ~12K tokens
CI get_symbol_body ~8K tokens
DC edit_block ~6K tokens
DC read_file ~4K tokens
CI search_verify ~8K tokens
= ~43K tokens total

Savings: ~83%
```

### Example 5: Relationship discovery before changes

**Bad (Manual tracing):**
```
Grep: find "import.*User" ~20K tokens
Read: each file ~45K tokens
Manual: trace dependencies ~30K tokens
= ~95K tokens (and still incomplete)
```

**Good (CG query):**
```
CG query_graph ~4K tokens
CG get_neighbors ~3K tokens
= ~7K tokens with complete relationship map

Savings: ~93%
```
```

Add these examples after existing Example 3.
  </action>
  <verify>Tool selection examples include Golden Pattern and relationship discovery with token comparisons</verify>
  <done>Three-server examples demonstrate significant token savings</done>
</task>

</tasks>

<verification>
1. MCP-SERVER-STATUS.md updated with CG connection (neo4j://localhost:7687)
2. TOOL-PRIORITY-RULES.md enhanced with CG tools section
3. Relationship operations added to tool selection matrix (5 operations)
4. Decision tree includes CG branch for relationship analysis
5. Golden pattern integration documented with cross-reference
6. Quick reference card includes three-server selection
7. CG-specific common mistakes documented
8. Three-server examples show token efficiency gains
</verification>

<success_criteria>
1. TOOL-PRIORITY-RULES.md is 500+ lines (enhanced from 423 lines)
2. All CG tools documented (query_graph, find_path, get_neighbors)
3. Three-server hierarchy clear (Skills > DC > CI > CG > Native for relationships)
4. Golden pattern cross-reference enables full workflow documentation
5. Decision tree prevents native tool usage when CG/CI/DC available
6. MCP-SERVER-STATUS.md shows CG as connected with tested operations
7. CG tools positioned correctly in priority order (after Skills/DC/CI for relationships)
</success_criteria>

<output>
After completion, create `.planning/phases/03-documentation-consolidation/03-02-SUMMARY.md`
</output>
