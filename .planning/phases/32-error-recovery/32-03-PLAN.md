---
phase: 32
plan: 03
title: Graceful Degradation
wave: 1
depends_on: [32-02]
files_modified:
  - lib/gsi-core/fallback/degradation-handler.ts
  - lib/gsi-core/fallback/fallback-providers.ts
autonomous: true
must_haves:
  truths:
    - System continues on failures
    - Fallbacks provide alternatives
    - User experience maintained
  artifacts:
    - lib/gsi-core/fallback/degradation-handler.ts:120
    - lib/gsi-core/fallback/fallback-providers.ts:100
---

# 32-03: Graceful Degradation

## Objective
Implement graceful degradation for system failures.

## Tasks

### Task 1: Degradation Handler
**File**: `lib/gsi-core/fallback/degradation-handler.ts`
**Lines**: ~120

```typescript
import { FallbackProvider } from './fallback-providers.js';

export interface DegradationLevel {
  level: 'full' | 'reduced' | 'minimal' | 'offline';
  features: string[];
  message: string;
}

export class DegradationHandler {
  private providers: Map<string, FallbackProvider> = new Map();
  private currentLevel: DegradationLevel = {
    level: 'full',
    features: ['all'],
    message: 'All features available'
  };

  /**
   * Register a fallback provider
   */
  register(name: string, provider: FallbackProvider): void {
    this.providers.set(name, provider);
  }

  /**
   * Handle feature failure with fallback
   */
  async handle<T>(feature: string, primary: () => Promise<T>): Promise<T> {
    try {
      return await primary();
    } catch (error) {
      // Try fallback provider
      const provider = this.providers.get(feature);
      if (provider) {
        console.warn(`[GSI] Falling back for ${feature}`);
        this.downgrade(feature);
        return provider.provide() as Promise<T>;
      }

      // No fallback available
      throw error;
    }
  }

  /**
   * Downgrade degradation level
   */
  private downgrade(failedFeature: string): void {
    const levels: DegradationLevel[] = [
      { level: 'full', features: ['all'], message: 'All features available' },
      { level: 'reduced', features: ['core', 'basic'], message: 'Some features unavailable' },
      { level: 'minimal', features: ['core'], message: 'Running in minimal mode' },
      { level: 'offline', features: [], message: 'Offline mode - limited functionality' }
    ];

    const currentIndex = levels.findIndex(l => l.level === this.currentLevel.level);
    if (currentIndex < levels.length - 1) {
      this.currentLevel = levels[currentIndex + 1];
      console.warn(`[GSI] Degraded to ${this.currentLevel.level} mode: ${this.currentLevel.message}`);
    }
  }

  /**
   * Get current degradation level
   */
  getCurrentLevel(): DegradationLevel {
    return this.currentLevel;
  }

  /**
   * Check if feature is available
   */
  isAvailable(feature: string): boolean {
    if (this.currentLevel.features.includes('all')) return true;
    return this.currentLevel.features.includes(feature);
  }

  /**
   * Reset to full functionality
   */
  reset(): void {
    this.currentLevel = {
      level: 'full',
      features: ['all'],
      message: 'All features available'
    };
  }
}
```

### Task 2: Fallback Providers
**File**: `lib/gsi-core/fallback/fallback-providers.ts`
**Lines**: ~100

```typescript
export interface FallbackProvider {
  provide(): Promise<unknown>;
}

export class CachedResponseProvider implements FallbackProvider {
  private cache: Map<string, unknown>;

  constructor(cache: Map<string, unknown>) {
    this.cache = cache;
  }

  async provide(): Promise<unknown> {
    // Return last known good response
    const lastValue = Array.from(this.cache.values()).pop();
    return lastValue ?? null;
  }
}

export class MockDataProvider implements FallbackProvider {
  private mockData: unknown;

  constructor(mockData: unknown) {
    this.mockData = mockData;
  }

  async provide(): Promise<unknown> {
    return this.mockData;
  }
}

export class LocalStorageProvider implements FallbackProvider {
  private key: string;

  constructor(key: string) {
    this.key = key;
  }

  async provide(): Promise<unknown> {
    // Read from local file storage
    const fs = await import('fs/promises');
    try {
      const data = await fs.readFile(this.key, 'utf-8');
      return JSON.parse(data);
    } catch {
      return null;
    }
  }
}

export class DefaultProvider implements FallbackProvider {
  private defaultValue: unknown;

  constructor(defaultValue: unknown) {
    this.defaultValue = defaultValue;
  }

  async provide(): Promise<unknown> {
    return this.defaultValue;
  }
}
```

## Output
- Degradation handler with levels
- Multiple fallback provider types
- Feature availability checking

**Next**: 32-04 - Circuit Breaker
