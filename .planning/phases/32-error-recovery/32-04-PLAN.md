---
phase: 32
plan: 04
title: Circuit Breaker
wave: 2
depends_on: [32-03]
files_modified:
  - lib/gsi-core/circuit/circuit-breaker.ts
  - lib/gsi-core/circuit/circuit-state.ts
autonomous: true
must_haves:
  truths:
    - Failures detected quickly
    - Circuit opens on threshold
    - Recovery attempts gradual
  artifacts:
    - lib/gsi-core/circuit/circuit-breaker.ts:130
    - lib/gsi-core/circuit/circuit-state.ts:60
---

# 32-04: Circuit Breaker

## Objective
Implement circuit breaker pattern for external service calls.

## Tasks

### Task 1: Circuit Breaker
**File**: `lib/gsi-core/circuit/circuit-breaker.ts`
**Lines**: ~130

```typescript
import { CircuitState, CircuitStatus } from './circuit-state.js';

export interface CircuitConfig {
  failureThreshold: number;
  successThreshold: number;
  timeout: number;
  resetTimeout: number;
}

export class CircuitBreaker {
  private state: CircuitState;
  private config: CircuitConfig;
  private failures: number = 0;
  private successes: number = 0;
  private lastFailureTime: number = 0;

  constructor(config: Partial<CircuitConfig> = {}) {
    this.config = {
      failureThreshold: config.failureThreshold ?? 5,
      successThreshold: config.successThreshold ?? 3,
      timeout: config.timeout ?? 30000,
      resetTimeout: config.resetTimeout ?? 60000
    };
    this.state = new CircuitState();
  }

  /**
   * Execute function through circuit breaker
   */
  async execute<T>(fn: () => Promise<T>): Promise<T> {
    // Check circuit state
    if (this.state.status === CircuitStatus.OPEN) {
      if (this.shouldAttemptReset()) {
        this.state.halfOpen();
      } else {
        throw new Error('Circuit breaker is open');
      }
    }

    try {
      const result = await this.executeWithTimeout(fn);
      this.onSuccess();
      return result;
    } catch (error) {
      this.onFailure();
      throw error;
    }
  }

  /**
   * Execute with timeout
   */
  private async executeWithTimeout<T>(fn: () => Promise<T>): Promise<T> {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error('Circuit breaker timeout'));
      }, this.config.timeout);

      fn()
        .then(result => {
          clearTimeout(timer);
          resolve(result);
        })
        .catch(error => {
          clearTimeout(timer);
          reject(error);
        });
    });
  }

  /**
   * Handle successful execution
   */
  private onSuccess(): void {
    this.failures = 0;
    this.successes++;

    if (this.state.status === CircuitStatus.HALF_OPEN) {
      if (this.successes >= this.config.successThreshold) {
        this.state.close();
        this.successes = 0;
      }
    }
  }

  /**
   * Handle failed execution
   */
  private onFailure(): void {
    this.successes = 0;
    this.failures++;
    this.lastFailureTime = Date.now();

    if (this.state.status === CircuitStatus.HALF_OPEN) {
      this.state.open();
    } else if (this.failures >= this.config.failureThreshold) {
      this.state.open();
    }
  }

  /**
   * Check if should attempt reset
   */
  private shouldAttemptReset(): boolean {
    return Date.now() - this.lastFailureTime >= this.config.resetTimeout;
  }

  /**
   * Get current status
   */
  getStatus(): CircuitStatus {
    return this.state.status;
  }

  /**
   * Force open circuit
   */
  trip(): void {
    this.state.open();
    this.lastFailureTime = Date.now();
  }

  /**
   * Force close circuit
   */
  reset(): void {
    this.state.close();
    this.failures = 0;
    this.successes = 0;
  }
}
```

### Task 2: Circuit State
**File**: `lib/gsi-core/circuit/circuit-state.ts`
**Lines**: ~60

```typescript
export enum CircuitStatus {
  CLOSED = 'closed',
  OPEN = 'open',
  HALF_OPEN = 'half_open'
}

export class CircuitState {
  status: CircuitStatus = CircuitStatus.CLOSED;
  private lastChange: number = Date.now();

  /**
   * Open the circuit
   */
  open(): void {
    this.transition(CircuitStatus.OPEN);
  }

  /**
   * Close the circuit
   */
  close(): void {
    this.transition(CircuitStatus.CLOSED);
  }

  /**
   * Set to half-open
   */
  halfOpen(): void {
    this.transition(CircuitStatus.HALF_OPEN);
  }

  /**
   * Get time since last change
   */
  getTimeSinceChange(): number {
    return Date.now() - this.lastChange;
  }

  private transition(to: CircuitStatus): void {
    if (this.status !== to) {
      this.status = to;
      this.lastChange = Date.now();
    }
  }
}
```

## Output
- Circuit breaker with configurable thresholds
- Timeout handling
- Automatic recovery attempts

**Next**: 32-05 - Error Reporting
