---
phase: 32
plan: 02
title: Retry Logic
wave: 1
depends_on: [32-01]
files_modified:
  - lib/gsi-core/retry/retry-handler.ts
  - lib/gsi-core/retry/backoff-strategies.ts
autonomous: true
must_haves:
  truths:
    - Transient errors retried
    - Backoff strategies implemented
    - Max attempts enforced
  artifacts:
    - lib/gsi-core/retry/retry-handler.ts:120
    - lib/gsi-core/retry/backoff-strategies.ts:80
---

# 32-02: Retry Logic

## Objective
Implement robust retry logic with multiple backoff strategies.

## Tasks

### Task 1: Retry Handler
**File**: `lib/gsi-core/retry/retry-handler.ts`
**Lines**: ~120

```typescript
import { BackoffStrategy, ExponentialBackoff, LinearBackoff } from './backoff-strategies.js';

export interface RetryConfig {
  maxAttempts: number;
  backoff: BackoffStrategy;
  retryableErrors: string[];
}

export interface RetryResult<T> {
  success: boolean;
  result?: T;
  error?: Error;
  attempts: number;
  totalDelay: number;
}

export class RetryHandler {
  private config: RetryConfig;

  constructor(config: Partial<RetryConfig> = {}) {
    this.config = {
      maxAttempts: config.maxAttempts ?? 3,
      backoff: config.backoff ?? new ExponentialBackoff(1000, 30000),
      retryableErrors: config.retryableErrors ?? ['ECONNRESET', 'ETIMEDOUT', 'ENOTFOUND']
    };
  }

  /**
   * Execute function with retry logic
   */
  async execute<T>(fn: () => Promise<T>): Promise<RetryResult<T>> {
    let attempts = 0;
    let totalDelay = 0;
    let lastError: Error | undefined;

    while (attempts < this.config.maxAttempts) {
      attempts++;

      try {
        const result = await fn();
        return { success: true, result, attempts, totalDelay };
      } catch (error) {
        lastError = error instanceof Error ? error : new Error(String(error));

        // Check if error is retryable
        if (!this.isRetryable(lastError)) {
          return { success: false, error: lastError, attempts, totalDelay };
        }

        // Don't delay after last attempt
        if (attempts < this.config.maxAttempts) {
          const delay = this.config.backoff.getDelay(attempts);
          totalDelay += delay;
          await this.sleep(delay);
        }
      }
    }

    return { success: false, error: lastError, attempts, totalDelay };
  }

  /**
   * Check if error is retryable
   */
  private isRetryable(error: Error): boolean {
    return this.config.retryableErrors.some(code =>
      error.message.includes(code) || (error as NodeJS.ErrnoException).code === code
    );
  }

  private sleep(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Task 2: Backoff Strategies
**File**: `lib/gsi-core/retry/backoff-strategies.ts`
**Lines**: ~80

```typescript
export interface BackoffStrategy {
  getDelay(attempt: number): number;
}

export class ExponentialBackoff implements BackoffStrategy {
  constructor(
    private baseDelay: number = 1000,
    private maxDelay: number = 30000,
    private multiplier: number = 2
  ) {}

  getDelay(attempt: number): number {
    const delay = this.baseDelay * Math.pow(this.multiplier, attempt - 1);
    return Math.min(delay, this.maxDelay);
  }
}

export class LinearBackoff implements BackoffStrategy {
  constructor(
    private baseDelay: number = 1000,
    private increment: number = 1000,
    private maxDelay: number = 30000
  ) {}

  getDelay(attempt: number): number {
    const delay = this.baseDelay + (this.increment * (attempt - 1));
    return Math.min(delay, this.maxDelay);
  }
}

export class FixedBackoff implements BackoffStrategy {
  constructor(private delay: number = 1000) {}

  getDelay(): number {
    return this.delay;
  }
}

export class JitteredBackoff implements BackoffStrategy {
  constructor(
    private strategy: BackoffStrategy,
    private jitterPercent: number = 0.1
  ) {}

  getDelay(attempt: number): number {
    const baseDelay = this.strategy.getDelay(attempt);
    const jitter = baseDelay * this.jitterPercent * (Math.random() * 2 - 1);
    return Math.max(0, Math.round(baseDelay + jitter));
  }
}
```

## Output
- Retry handler with configurable attempts
- Multiple backoff strategies
- Smart retryable error detection

**Next**: 32-03 - Graceful Degradation
