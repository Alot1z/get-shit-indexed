---
phase: 32
plan: 06
title: Recovery Automation
wave: 3
depends_on: [32-05]
files_modified:
  - lib/gsi-core/recovery/recovery-orchestrator.ts
  - lib/gsi-core/recovery/recovery-strategies.ts
autonomous: false
must_haves:
  truths:
    - Recovery actions automated
    - Strategies matched to errors
    - Feedback loop established
  artifacts:
    - lib/gsi-core/recovery/recovery-orchestrator.ts:140
    - lib/gsi-core/recovery/recovery-strategies.ts:100
---

# 32-06: Recovery Automation

## Objective
Implement automated recovery from common error scenarios.

## Tasks

### Task 1: Recovery Orchestrator
**File**: `lib/gsi-core/recovery/recovery-orchestrator.ts`
**Lines**: ~140

```typescript
import { RecoveryStrategy, RecoveryResult } from './recovery-strategies.js';
import { ErrorReport } from '../reporting/error-reporter.js';

export interface RecoveryConfig {
  maxAttempts: number;
  backoffMs: number;
  enableAutoRecovery: boolean;
}

export class RecoveryOrchestrator {
  private strategies: Map<string, RecoveryStrategy> = new Map();
  private config: RecoveryConfig;
  private recoveryHistory: Array<{ error: ErrorReport; result: RecoveryResult }> = [];

  constructor(config: Partial<RecoveryConfig> = {}) {
    this.config = {
      maxAttempts: config.maxAttempts ?? 3,
      backoffMs: config.backoffMs ?? 1000,
      enableAutoRecovery: config.enableAutoRecovery ?? true
    };
  }

  /**
   * Register a recovery strategy
   */
  register(category: string, strategy: RecoveryStrategy): void {
    this.strategies.set(category, strategy);
  }

  /**
   * Attempt recovery from error
   */
  async recover(errorReport: ErrorReport): Promise<RecoveryResult> {
    if (!this.config.enableAutoRecovery) {
      return { success: false, message: 'Auto-recovery disabled' };
    }

    const strategy = this.strategies.get(errorReport.formatted.category);
    if (!strategy) {
      return { success: false, message: `No strategy for category: ${errorReport.formatted.category}` };
    }

    let lastResult: RecoveryResult = { success: false, message: 'No attempts made' };

    for (let attempt = 1; attempt <= this.config.maxAttempts; attempt++) {
      console.log(`[Recovery] Attempt ${attempt}/${this.config.maxAttempts} for ${errorReport.formatted.category}`);

      try {
        lastResult = await strategy.recover(errorReport);

        if (lastResult.success) {
          this.recoveryHistory.push({ error: errorReport, result: lastResult });
          return lastResult;
        }

        // Wait before next attempt
        if (attempt < this.config.maxAttempts) {
          await this.delay(this.config.backoffMs * attempt);
        }
      } catch (error) {
        lastResult = {
          success: false,
          message: `Recovery attempt ${attempt} failed: ${error}`
        };
      }
    }

    this.recoveryHistory.push({ error: errorReport, result: lastResult });
    return lastResult;
  }

  /**
   * Get recovery statistics
   */
  getStats(): { total: number; successful: number; failed: number } {
    const total = this.recoveryHistory.length;
    const successful = this.recoveryHistory.filter(h => h.result.success).length;
    return { total, successful, failed: total - successful };
  }

  /**
   * Get recovery history
   */
  getHistory(): Array<{ error: ErrorReport; result: RecoveryResult }> {
    return [...this.recoveryHistory];
  }

  private delay(ms: number): Promise<void> {
    return new Promise(resolve => setTimeout(resolve, ms));
  }
}
```

### Task 2: Recovery Strategies
**File**: `lib/gsi-core/recovery/recovery-strategies.ts`
**Lines**: ~100

```typescript
import type { ErrorReport } from '../reporting/error-reporter.js';

export interface RecoveryResult {
  success: boolean;
  message: string;
  actions?: string[];
}

export interface RecoveryStrategy {
  recover(error: ErrorReport): Promise<RecoveryResult>;
}

export class FileSystemRecoveryStrategy implements RecoveryStrategy {
  async recover(error: ErrorReport): Promise<RecoveryResult> {
    const actions: string[] = [];

    // Try creating missing directories
    if (error.error.message.includes('ENOENT')) {
      try {
        const fs = await import('fs/promises');
        const path = error.context.metadata.path as string;
        if (path) {
          await fs.mkdir(path, { recursive: true });
          actions.push(`Created directory: ${path}`);
        }
      } catch {
        // Ignore
      }
    }

    return {
      success: actions.length > 0,
      message: actions.length > 0 ? 'Filesystem recovered' : 'Could not recover',
      actions
    };
  }
}

export class NetworkRecoveryStrategy implements RecoveryStrategy {
  async recover(error: ErrorReport): Promise<RecoveryResult> {
    const actions: string[] = [];

    // Try reconnecting
    if (error.error.message.includes('ECONNREFUSED')) {
      actions.push('Attempted reconnection');
      // Actual reconnection logic would go here
    }

    return {
      success: false, // Network recovery typically requires manual intervention
      message: 'Network recovery requires manual intervention',
      actions
    };
  }
}

export class CacheRecoveryStrategy implements RecoveryStrategy {
  async recover(error: ErrorReport): Promise<RecoveryResult> {
    // Clear corrupted cache
    const actions = ['Cleared cache'];

    return {
      success: true,
      message: 'Cache cleared successfully',
      actions
    };
  }
}
```

## Output
- Recovery orchestrator with strategies
- Category-based recovery matching
- Recovery statistics tracking

**Phase 32 Complete**
