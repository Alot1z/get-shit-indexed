---
phase: 17-complexity-prediction
plan: 02
name: PreToolUse Complexity Hook
type: execute
wave: 1
depends_on: []
files_modified:
  - hooks/pre-tool-use/complexity-check.js
  - lib/complexity/scorer.js
autonomous: true
estimated_tasks: 7
must_haves:
  truths:
    - "PreToolUse hook triggers before every agent spawn"
    - "Complexity score calculated from plan structure"
    - "MCP tools (DC, CI, CG) used for analysis"
    - "Action decision returned: execute/warn/auto-split"
  artifacts:
    - path: "hooks/pre-tool-use/complexity-check.js"
      provides: "PreToolUse hook for complexity prediction"
      exports: ["run"]
    - path: "lib/complexity/scorer.js"
      provides: "Complexity scoring algorithm"
      exports: ["calculateComplexityScore", "decideAction"]
  key_links:
    - from: "hooks/pre-tool-use/complexity-check.js"
      to: "lib/complexity/scorer.js"
      via: "require"
      pattern: "require.*scorer"
    - from: "lib/complexity/scorer.js"
      to: "lib/complexity/model-awareness.js"
      via: "require"
      pattern: "require.*model-awareness"
---

<objective>
Create the PreToolUse complexity hook that triggers complexity prediction before agent execution. This hook integrates Layer 1 (Model Awareness) and provides the foundation for Layer 2 (Complexity Analysis).

Purpose: Automatically analyze plan complexity before any execution to prevent context limit failures and enable intelligent auto-splitting.

Output: A working PreToolUse hook that calculates complexity scores and returns action decisions.
</objective>

<execution_context>
@C:/Users/mose/.claude/get-shit-indexed/workflows/execute-plan.md
@C:/Users/mose/.claude/get-shit-indexed/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-complexity-prediction/17-CONTEXT.md
@.planning/phases/17-complexity-prediction/17-01-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create complexity scorer module</name>
  <files>lib/complexity/scorer.js</files>
  <action>
Create the complexity scoring module with the scoring formula from CONTEXT.md:

```javascript
// Complexity scoring weights
const WEIGHTS = {
  fileOp: 2,        // Each file read = 2-5K tokens
  symbolQuery: 5,   // Each symbol extraction = 3-10K tokens
  cgQuery: 8,       // Each graph query = 5-15K tokens
  task: 10,         // Each task = 10-20K tokens
  crossRef: 3       // Each cross-reference = 5K tokens
};

function calculateComplexityScore(plan) {
  const score = (
    (plan.fileOps || 0) * WEIGHTS.fileOp +
    (plan.symbolQueries || 0) * WEIGHTS.symbolQuery +
    (plan.cgQueries || 0) * WEIGHTS.cgQuery +
    (plan.tasks?.length || 0) * WEIGHTS.task +
    (plan.crossRefs || 0) * WEIGHTS.crossRef
  ) / 100;
  return Math.round(score * 10) / 10; // Round to 1 decimal
}
```

Export the weights and calculateComplexityScore function.
  </action>
  <verify>calculateComplexityScore({fileOps: 10, tasks: 5}) returns a numeric score</verify>
  <done>scorer.js created with complexity scoring formula</done>
</task>

<task type="auto">
  <name>Task 2: Implement decideAction function</name>
  <files>lib/complexity/scorer.js</files>
  <action>
Implement the action decision function using model thresholds:

```javascript
const { getModelThresholds } = require('./model-awareness');

async function decideAction(score) {
  const thresholds = await getModelThresholds();
  
  if (score > thresholds.split_threshold) {
    return {
      action: "auto-split",
      reason: `Score ${score} exceeds ${thresholds.split_threshold} threshold`,
      subPhaseCount: Math.ceil(score / thresholds.split_threshold)
    };
  } else if (score > thresholds.warn_threshold) {
    return {
      action: "warn",
      reason: `Score ${score} in warning range`,
      options: ["proceed", "split", "manual"]
    };
  } else {
    return {
      action: "execute",
      reason: `Score ${score} below warning threshold`
    };
  }
}
```

Export the decideAction function.
  </action>
  <verify>decideAction(85) returns action: "auto-split", decideAction(30) returns action: "execute"</verify>
  <done>decideAction function returns appropriate action based on model thresholds</done>
</task>

<task type="auto">
  <name>Task 3: Create PreToolUse hook directory</name>
  <files>hooks/pre-tool-use/complexity-check.js</files>
  <action>
Create the hooks/pre-tool-use directory if it does not exist, then create the complexity-check.js stub file.

Use mcp__desktop-commander__create_directory for hooks/pre-tool-use.
  </action>
  <verify>mcp__desktop-commander__list_directory path="hooks/pre-tool-use" shows complexity-check.js</verify>
  <done>hooks/pre-tool-use/ directory created with complexity-check.js stub</done>
</task>

<task type="auto">
  <name>Task 4: Implement hook trigger detection</name>
  <files>hooks/pre-tool-use/complexity-check.js</files>
  <action>
Implement the logic to detect when complexity prediction should trigger:

```javascript
const TRIGGER_TOOLS = [
  'Task',           // Agent spawn
  'execute-phase',  // Phase execution
  'execute-plan'    // Plan execution
];

function shouldTrigger(toolName, context) {
  return TRIGGER_TOOLS.includes(toolName) ||
         context?.planFile?.endsWith('-PLAN.md');
}
```

The hook should only run complexity prediction for relevant operations.
  </action>
  <verify>shouldTrigger('Task', {}) returns true, shouldTrigger('Read', {}) returns false</verify>
  <done>Trigger detection identifies when to run complexity prediction</done>
</task>

<task type="auto">
  <name>Task 5: Implement plan analysis with MCP tools</name>
  <files>hooks/pre-tool-use/complexity-check.js</files>
  <action>
Implement plan analysis using MCP tools to count operations:

```javascript
async function analyzePlan(planPath) {
  // Use DC to read plan file
  const content = await dc.read_file(planPath);
  
  // Count tasks (XML task elements)
  const taskCount = (content.match(/<task/g) || []).length;
  
  // Count file references in <files> elements
  const fileOps = (content.match(/<files>[\s\S]*?<\/files>/g) || []).length;
  
  // Estimate symbol queries (one per task typically)
  const symbolQueries = taskCount;
  
  // Estimate CG queries (dependency analysis)
  const cgQueries = Math.ceil(taskCount / 2);
  
  // Count cross-references (@-references)
  const crossRefs = (content.match(/@[a-zA-Z0-9_\-\/]+/g) || []).length;
  
  return { fileOps, symbolQueries, cgQueries, tasks: taskCount, crossRefs };
}
```

Import and use Desktop Commander MCP tools.
  </action>
  <verify>analyzePlan returns object with all complexity factors counted</verify>
  <done>Plan analysis uses DC MCP to extract complexity factors from plans</done>
</task>

<task type="auto">
  <name>Task 6: Implement main hook run function</name>
  <files>hooks/pre-tool-use/complexity-check.js</files>
  <action>
Implement the main run function that orchestrates complexity prediction:

```javascript
const { calculateComplexityScore, decideAction } = require('../../lib/complexity/scorer');

async function run(toolName, context) {
  if (!shouldTrigger(toolName, context)) {
    return { skip: true };
  }
  
  const planPath = context?.planFile || context?.arguments?.planFile;
  if (!planPath) {
    return { skip: true, reason: "No plan file in context" };
  }
  
  const planMetrics = await analyzePlan(planPath);
  const score = calculateComplexityScore(planMetrics);
  const action = await decideAction(score);
  
  return {
    score,
    action: action.action,
    reason: action.reason,
    metrics: planMetrics,
    options: action.options,
    subPhaseCount: action.subPhaseCount
  };
}

module.exports = { run, shouldTrigger, analyzePlan };
```
  </action>
  <verify>run function returns object with score, action, and metrics</verify>
  <done>Main hook run function orchestrates full complexity prediction flow</done>
</task>

<task type="auto">
  <name>Task 7: Update lib/complexity/index.js with scorer exports</name>
  <files>lib/complexity/index.js</files>
  <action>
Update the main index.js to also export scorer functions:

```javascript
const modelAwareness = require('./model-awareness');
const scorer = require('./scorer');

module.exports = {
  // Layer 1: Model Awareness
  ...modelAwareness,
  // Scoring
  ...scorer
};
```

This provides a unified API for all complexity prediction functions.
  </action>
  <verify>require('./lib/complexity') returns object with scorer functions</verify>
  <done>index.js exports unified API including scorer functions</done>
</task>

</tasks>

<verification>
Verify Layer 2 (PreToolUse) completion by:
1. mcp__desktop-commander__read_file("hooks/pre-tool-use/complexity-check.js") - should contain run, shouldTrigger, analyzePlan
2. mcp__desktop-commander__read_file("lib/complexity/scorer.js") - should contain WEIGHTS, calculateComplexityScore, decideAction
3. Complexity score calculation works with mock plan data
4. Action decision respects model thresholds from Layer 1
</verification>

<success_criteria>
- [ ] scorer.js with complexity scoring formula (5 weights)
- [ ] decideAction uses model thresholds from Layer 1
- [ ] PreToolUse hook triggers for Task, execute-phase, execute-plan
- [ ] Plan analysis counts tasks, files, symbols, CG queries, cross-refs
- [ ] Main run function orchestrates full prediction
- [ ] Unified index.js exports all functions
</success_criteria>

<output>
After completion, create `.planning/phases/17-complexity-prediction/17-02-SUMMARY.md` documenting:
- PreToolUse hook implementation
- Complexity scoring formula with weights
- Action decision logic (execute/warn/auto-split)
- Integration with Layer 1 model awareness
</output>
