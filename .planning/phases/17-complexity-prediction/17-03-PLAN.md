---
phase: 17-complexity-prediction
plan: 03
name: Integrated Cognitive Orchestration (Layer 2)
type: execute
wave: 2
depends_on:
  - 17-01
  - 17-02
files_modified:
  - lib/complexity/cognitive-flow.js
  - lib/complexity/tractatus-ci-phase.js
  - lib/complexity/sequential-cg-phase.js
  - lib/complexity/debug-dc-phase.js
autonomous: true
estimated_tasks: 8
must_haves:
  truths:
    - "Three-phase cognitive flow executes iteratively (NOT parallel)"
    - "Tractatus + CI provides structural analysis"
    - "Sequential + CG provides process assessment"
    - "Debug + DC provides pattern learning"
    - "Final score combines all phase outputs"
  artifacts:
    - path: "lib/complexity/cognitive-flow.js"
      provides: "Main cognitive orchestration"
      exports: ["runCognitiveFlow", "ComplexityResult"]
    - path: "lib/complexity/tractatus-ci-phase.js"
      provides: "Phase 1: Structure analysis"
      exports: ["runStructurePhase"]
    - path: "lib/complexity/sequential-cg-phase.js"
      provides: "Phase 2: Process assessment"
      exports: ["runProcessPhase"]
    - path: "lib/complexity/debug-dc-phase.js"
      provides: "Phase 3: Pattern learning"
      exports: ["runLearningPhase"]
  key_links:
    - from: "lib/complexity/cognitive-flow.js"
      to: "tractatus-ci-phase.js"
      via: "require"
    - from: "lib/complexity/cognitive-flow.js"
      to: "sequential-cg-phase.js"
      via: "require"
    - from: "lib/complexity/cognitive-flow.js"
      to: "debug-dc-phase.js"
      via: "require"
---

<objective>
Implement Layer 2: Integrated Cognitive Orchestration with the three-phase iterative flow.

Purpose: Create a sophisticated complexity analysis system that uses thinking servers (Tractatus, Sequential, Debug) interleaved with MCP servers (CI, CG, DC) for comprehensive plan analysis.

Output: A working cognitive flow that executes Structure → Process → Learning phases iteratively (NOT parallel) to produce refined complexity scores.
</objective>

<execution_context>
@C:/Users/mose/.claude/get-shit-indexed/workflows/execute-plan.md
@C:/Users/mose/.claude/get-shit-indexed/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-complexity-prediction/17-CONTEXT.md
@.planning/phases/17-complexity-prediction/17-01-PLAN.md
@.planning/phases/17-complexity-prediction/17-02-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create Phase 1 - Structure Analysis (Tractatus + CI)</name>
  <files>lib/complexity/tractatus-ci-phase.js</files>
  <action>
Create the structure analysis phase that uses Tractatus thinking interleaved with Code-Index MCP:

```javascript
async function runStructurePhase(planPath, planMetrics) {
  // Phase 1.1: Start Tractatus analysis
  const tractatus = await mcp__tractatus__tractatus_thinking({
    operation: "start",
    concept: "Analyze plan structure for complexity factors",
    depth_limit: 3
  });
  const sessionId = tractatus.session_id;

  // Phase 1.2: Use CI to get file summaries
  const files = planMetrics.files || [];
  const fileSummaries = await Promise.all(
    files.map(f => mcp__code_index__get_file_summary({ file_path: f }))
  );
  
  // Phase 1.3: Add structural propositions
  await mcp__tractatus__tractatus_thinking({
    operation: "add",
    session_id: sessionId,
    content: `Files analyzed: ${fileSummaries.length}, total lines: ${fileSummaries.reduce((s, f) => s + (f.lineCount || 0), 0)}`
  });
  
  // Phase 1.4: Export analysis
  const analysis = await mcp__tractatus__tractatus_thinking({
    operation: "export",
    session_id: sessionId,
    format: "json"
  });
  
  return {
    fileCount: files.length,
    totalLines: fileSummaries.reduce((s, f) => s + (f.lineCount || 0), 0),
    structuralComplexity: analysis.complexity || 5,
    tractatusSession: sessionId
  };
}

module.exports = { runStructurePhase };
```
  </action>
  <verify>runStructurePhase returns object with fileCount, totalLines, structuralComplexity</verify>
  <done>tractatus-ci-phase.js implements iterative Tractatus + CI structure analysis</done>
</task>

<task type="auto">
  <name>Task 2: Create Phase 2 - Process Assessment (Sequential + CG)</name>
  <files>lib/complexity/sequential-cg-phase.js</files>
  <action>
Create the process assessment phase that uses Sequential thinking interleaved with CodeGraphContext:

```javascript
async function runProcessPhase(planMetrics, structureResult) {
  // Phase 2.1: Start sequential thinking
  let thought = await mcp__sequential__sequentialthinking({
    thought: `Beginning process assessment. Files: ${structureResult.fileCount}, Lines: ${structureResult.totalLines}`,
    thoughtNumber: 1,
    totalThoughts: 4,
    nextThoughtNeeded: true
  });

  // Phase 2.2: Use CG for dependency analysis
  const affectedFiles = planMetrics.files || [];
  const dependencies = await mcp__codegraph__analyze_code_relationships({
    query_type: "module_deps",
    target: affectedFiles[0] || "unknown"
  });
  
  // Phase 2.3: Continue thinking with dependency info
  thought = await mcp__sequential__sequentialthinking({
    thought: `Dependencies found: ${dependencies.length || 0}. Cross-file complexity impact.`,
    thoughtNumber: 2,
    totalThoughts: 4,
    nextThoughtNeeded: true
  });
  
  // Phase 2.4: Calculate dependency impact
  const dependencyWeight = (dependencies.length || 0) * 0.5;
  
  thought = await mcp__sequential__sequentialthinking({
    thought: `Dependency weight calculated: ${dependencyWeight}`,
    thoughtNumber: 3,
    totalThoughts: 4,
    nextThoughtNeeded: true
  });
  
  // Phase 2.5: Final recommendation
  thought = await mcp__sequential__sequentialthinking({
    thought: `Process assessment complete. Recommended action based on combined factors.`,
    thoughtNumber: 4,
    totalThoughts: 4,
    nextThoughtNeeded: false
  });

  return {
    dependencyCount: dependencies.length || 0,
    dependencyWeight,
    processComplexity: 5 + dependencyWeight,
    recommendation: thought?.answer || "proceed"
  };
}

module.exports = { runProcessPhase };
```
  </action>
  <verify>runProcessPhase returns object with dependencyCount, dependencyWeight, processComplexity</verify>
  <done>sequential-cg-phase.js implements iterative Sequential + CG process assessment</done>
</task>

<task type="auto">
  <name>Task 3: Create Phase 3 - Pattern Learning (Debug + DC)</name>
  <files>lib/complexity/debug-dc-phase.js</files>
  <action>
Create the learning phase that uses Debug thinking interleaved with Desktop Commander:

```javascript
async function runLearningPhase(score, modelSpecs) {
  // Phase 3.1: Query similar past patterns FIRST (learning-first approach)
  const pastPatterns = await mcp__debug__debug_thinking({
    action: "query",
    queryType: "similar-problems",
    parameters: {
      pattern: `complexity score ${score}`,
      limit: 5,
      minSimilarity: 0.3
    }
  });

  // Phase 3.2: Read model specs via DC
  const specsContent = await mcp__desktop__read_file({ path: ".planning/model-specs.json" });
  const specs = JSON.parse(specsContent);

  // Phase 3.3: Create observation node for this assessment
  const observation = await mcp__debug__debug_thinking({
    action: "create",
    nodeType: "observation",
    content: `Complexity assessment: score=${score}, model=${modelSpecs.modelId}, action=${modelSpecs.action}`,
    metadata: {
      score,
      model: modelSpecs.modelId,
      action: modelSpecs.action,
      timestamp: new Date().toISOString()
    }
  });

  // Phase 3.4: Connect to similar patterns if found
  if (pastPatterns.results && pastPatterns.results.length > 0) {
    for (const pattern of pastPatterns.results.slice(0, 3)) {
      await mcp__debug__debug_thinking({
        action: "connect",
        from: observation.nodeId,
        to: pattern.id,
        type: "supports",
        strength: pattern.similarity
      });
    }
  }

  return {
    pastPatternCount: pastPatterns.results?.length || 0,
    observationId: observation.nodeId,
    learningApplied: pastPatterns.results?.length > 0
  };
}

module.exports = { runLearningPhase };
```
  </action>
  <verify>runLearningPhase returns object with pastPatternCount, observationId, learningApplied</verify>
  <done>debug-dc-phase.js implements learning-first approach with Debug + DC</done>
</task>

<task type="auto">
  <name>Task 4: Create main cognitive orchestration flow</name>
  <files>lib/complexity/cognitive-flow.js</files>
  <action>
Create the main orchestration that runs all three phases iteratively:

```javascript
const { runStructurePhase } = require('./tractatus-ci-phase');
const { runProcessPhase } = require('./sequential-cg-phase');
const { runLearningPhase } = require('./debug-dc-phase');
const { calculateComplexityScore, decideAction } = require('./scorer');

async function runCognitiveFlow(planPath, planMetrics) {
  // Execute phases ITERATIVELY (NOT parallel)
  
  // Phase 1: Structure (Tractatus + CI)
  const structureResult = await runStructurePhase(planPath, planMetrics);
  
  // Phase 2: Process (Sequential + CG) - uses Phase 1 results
  const processResult = await runProcessPhase(planMetrics, structureResult);
  
  // Calculate base score from plan metrics
  const baseScore = calculateComplexityScore(planMetrics);
  
  // Combine scores with phase weights
  const combinedScore = (
    baseScore * 0.5 +
    structureResult.structuralComplexity * 0.25 +
    processResult.processComplexity * 0.25
  );
  
  // Get action decision
  const action = await decideAction(combinedScore);
  
  // Phase 3: Learning (Debug + DC) - uses combined score
  const learningResult = await runLearningPhase(combinedScore, {
    modelId: action.modelId,
    action: action.action,
    score: combinedScore
  });

  return {
    score: Math.round(combinedScore * 10) / 10,
    action: action.action,
    reason: action.reason,
    phases: {
      structure: structureResult,
      process: processResult,
      learning: learningResult
    },
    options: action.options,
    subPhaseCount: action.subPhaseCount
  };
}

module.exports = { runCognitiveFlow };
```
  </action>
  <verify>runCognitiveFlow returns object with score, action, phases</verify>
  <done>cognitive-flow.js orchestrates all three phases iteratively</done>
</task>

<task type="auto">
  <name>Task 5: Add error handling for MCP tool failures</name>
  <files>lib/complexity/cognitive-flow.js</files>
  <action>
Add graceful degradation for when MCP servers are unavailable:

```javascript
async function runCognitiveFlow(planPath, planMetrics) {
  const results = {
    score: 0,
    action: 'execute',
    phases: {},
    degraded: false
  };
  
  try {
    // Try full cognitive flow
    const structureResult = await runStructurePhase(planPath, planMetrics);
    results.phases.structure = structureResult;
  } catch (e) {
    // Fallback: Use basic scoring without Tractatus/CI
    results.phases.structure = { structuralComplexity: 5, degraded: true };
    results.degraded = true;
  }
  
  try {
    const processResult = await runProcessPhase(planMetrics, results.phases.structure);
    results.phases.process = processResult;
  } catch (e) {
    // Fallback: Skip dependency analysis
    results.phases.process = { processComplexity: 5, degraded: true };
    results.degraded = true;
  }
  
  // Always calculate score even if phases degraded
  const baseScore = calculateComplexityScore(planMetrics);
  results.score = baseScore; // Use base score when degraded
  
  try {
    const learningResult = await runLearningPhase(results.score, results);
    results.phases.learning = learningResult;
  } catch (e) {
    results.phases.learning = { learningApplied: false, degraded: true };
    results.degraded = true;
  }
  
  // Get action decision (always works - uses local thresholds)
  const action = await decideAction(results.score);
  results.action = action.action;
  results.reason = action.reason;
  
  return results;
}
```
  </action>
  <verify>Cognitive flow handles MCP failures gracefully and returns degraded results</verify>
  <done>Error handling allows graceful degradation when MCP servers unavailable</done>
</task>

<task type="auto">
  <name>Task 6: Create ComplexityResult class for type safety</name>
  <files>lib/complexity/cognitive-flow.js</files>
  <action>
Add a ComplexityResult class for structured result handling:

```javascript
class ComplexityResult {
  constructor(data) {
    this.score = data.score || 0;
    this.action = data.action || 'execute';
    this.reason = data.reason || '';
    this.phases = data.phases || {};
    this.degraded = data.degraded || false;
    this.options = data.options || [];
    this.subPhaseCount = data.subPhaseCount || 1;
    this.timestamp = new Date().toISOString();
  }
  
  shouldSplit() {
    return this.action === 'auto-split';
  }
  
  shouldWarn() {
    return this.action === 'warn';
  }
  
  canProceed() {
    return this.action === 'execute';
  }
  
  toJSON() {
    return {
      score: this.score,
      action: this.action,
      reason: this.reason,
      degraded: this.degraded,
      subPhaseCount: this.subPhaseCount
    };
  }
}

module.exports = { runCognitiveFlow, ComplexityResult };
```
  </action>
  <verify>ComplexityResult class provides shouldSplit(), shouldWarn(), canProceed() methods</verify>
  <done>ComplexityResult class provides structured result handling</done>
</task>

<task type="auto">
  <name>Task 7: Integrate cognitive flow with PreToolUse hook</name>
  <files>hooks/pre-tool-use/complexity-check.js</files>
  <action>
Update the PreToolUse hook to use the cognitive flow instead of simple scoring:

```javascript
const { runCognitiveFlow, ComplexityResult } = require('../../lib/complexity/cognitive-flow');

async function run(toolName, context) {
  if (!shouldTrigger(toolName, context)) {
    return { skip: true };
  }
  
  const planPath = context?.planFile || context?.arguments?.planFile;
  if (!planPath) {
    return { skip: true, reason: "No plan file in context" };
  }
  
  // Get plan metrics using DC
  const planMetrics = await analyzePlan(planPath);
  
  // Run full cognitive flow
  const result = await runCognitiveFlow(planPath, planMetrics);
  
  return new ComplexityResult(result);
}
```

This upgrades the hook from simple scoring to full cognitive analysis.
  </action>
  <verify>PreToolUse hook returns ComplexityResult with phase analysis</verify>
  <done>PreToolUse hook integrated with cognitive flow for rich analysis</done>
</task>

<task type="auto">
  <name>Task 8: Update lib/complexity/index.js with all exports</name>
  <files>lib/complexity/index.js</files>
  <action>
Update the main index to export all Layer 2 functions:

```javascript
const modelAwareness = require('./model-awareness');
const scorer = require('./scorer');
const cognitiveFlow = require('./cognitive-flow');
const tractatusCi = require('./tractatus-ci-phase');
const sequentialCg = require('./sequential-cg-phase');
const debugDc = require('./debug-dc-phase');

module.exports = {
  // Layer 1: Model Awareness
  ...modelAwareness,
  
  // Scoring
  ...scorer,
  
  // Layer 2: Cognitive Flow
  runCognitiveFlow: cognitiveFlow.runCognitiveFlow,
  ComplexityResult: cognitiveFlow.ComplexityResult,
  
  // Individual phases (for testing/debugging)
  runStructurePhase: tractatusCi.runStructurePhase,
  runProcessPhase: sequentialCg.runProcessPhase,
  runLearningPhase: debugDc.runLearningPhase
};
```
  </action>
  <verify>require('./lib/complexity') exports all cognitive flow functions</verify>
  <done>Unified index.js exports all Layer 1 and Layer 2 functions</done>
</task>

</tasks>

<verification>
Verify Layer 2 completion by:
1. mcp__desktop-commander__read_file("lib/complexity/cognitive-flow.js") - should contain runCognitiveFlow, ComplexityResult
2. mcp__desktop-commander__read_file("lib/complexity/tractatus-ci-phase.js") - should contain runStructurePhase
3. mcp__desktop-commander__read_file("lib/complexity/sequential-cg-phase.js") - should contain runProcessPhase
4. mcp__desktop-commander__read_file("lib/complexity/debug-dc-phase.js") - should contain runLearningPhase
5. Cognitive flow handles errors gracefully with degraded mode
</verification>

<success_criteria>
- [ ] tractatus-ci-phase.js with iterative Tractatus + CI analysis
- [ ] sequential-cg-phase.js with iterative Sequential + CG assessment
- [ ] debug-dc-phase.js with learning-first Debug + DC pattern
- [ ] cognitive-flow.js orchestrates all 3 phases iteratively
- [ ] Error handling with graceful degradation
- [ ] ComplexityResult class for structured results
- [ ] PreToolUse hook integrated with cognitive flow
- [ ] Unified index.js exports
</success_criteria>

<output>
After completion, create `.planning/phases/17-complexity-prediction/17-03-SUMMARY.md` documenting:
- Three-phase cognitive flow architecture
- Tractatus + CI integration for structure
- Sequential + CG integration for process
- Debug + DC integration for learning
- Error handling and graceful degradation
- ComplexityResult class API
</output>
