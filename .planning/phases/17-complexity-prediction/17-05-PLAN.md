---
phase: 17-complexity-prediction
plan: 05
name: Learning & Threshold Adaptation
type: execute
wave: 3
depends_on:
  - 17-01
  - 17-02
  - 17-03
  - 17-04
files_modified:
  - .planning/complexity-history.json
  - lib/complexity/learning.js
  - lib/complexity/threshold-adapter.js
autonomous: true
estimated_tasks: 6
must_haves:
  truths:
    - "Pattern learning captures complexity assessments in debug-thinking"
    - "Threshold adaptation adjusts based on success/failure patterns"
    - "complexity-history.json tracks all assessments"
    - "Learning improves predictions over time"
  artifacts:
    - path: ".planning/complexity-history.json"
      provides: "Historical complexity assessment data"
      contains: "score, action, result, model"
    - path: "lib/complexity/learning.js"
      provides: "Pattern learning with debug-thinking"
      exports: ["recordAssessment", "queryPatterns", "adaptFromHistory"]
    - path: "lib/complexity/threshold-adapter.js"
      provides: "Threshold auto-adjustment"
      exports: ["adaptThresholds", "getAdaptedThresholds"]
  key_links:
    - from: "lib/complexity/learning.js"
      to: "mcp__debug__debug_thinking"
      via: "query and create nodes"
    - from: "lib/complexity/threshold-adapter.js"
      to: ".planning/complexity-history.json"
      via: "dc.read_file"
    - from: "lib/complexity/threshold-adapter.js"
      to: ".planning/model-specs.json"
      via: "dc.write_file (adapted thresholds)"
---

<objective>
Create the Learning & Threshold Adaptation system that improves complexity predictions over time.

Purpose: Enable the Complexity Prediction System to learn from past assessments and automatically adapt thresholds based on success/failure patterns.

Output: A working learning system that records assessments, queries patterns, and adapts thresholds based on historical data.
</objective>

<execution_context>
@C:/Users/mose/.claude/get-shit-indexed/workflows/execute-plan.md
@C:/Users/mose/.claude/get-shit-indexed/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/17-complexity-prediction/17-CONTEXT.md
@.planning/phases/17-complexity-prediction/17-01-PLAN.md
@.planning/phases/17-complexity-prediction/17-02-PLAN.md
@.planning/phases/17-complexity-prediction/17-03-PLAN.md
@.planning/phases/17-complexity-prediction/17-04-PLAN.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create complexity-history.json structure</name>
  <files>.planning/complexity-history.json</files>
  <action>
Create the complexity history tracking file with initial structure:

```json
{
  "version": "1.0.0",
  "assessments": [],
  "adaptations": [],
  "statistics": {
    "totalAssessments": 0,
    "autoSplits": 0,
    "warnings": 0,
    "successRate": 1.0,
    "avgScore": 0
  },
  "lastUpdated": "2026-02-15T00:00:00.000Z"
}
```

This file will track all complexity assessments for pattern learning.
Use mcp__desktop-commander__write_file.
  </action>
  <verify>mcp__desktop-commander__read_file(".planning/complexity-history.json") returns valid JSON</verify>
  <done>complexity-history.json created with empty assessment array</done>
</task>

<task type="auto">
  <name>Task 2: Implement recordAssessment function</name>
  <files>lib/complexity/learning.js</files>
  <action>
Create the assessment recording function:

```javascript
const dc = require('../mcp/desktop-commander');

async function recordAssessment(assessment) {
  // Read current history
  const historyPath = '.planning/complexity-history.json';
  const history = JSON.parse(await dc.read_file({ path: historyPath }));
  
  // Create assessment record
  const record = {
    id: `assess-${Date.now()}`,
    timestamp: new Date().toISOString(),
    planPath: assessment.planPath,
    score: assessment.score,
    action: assessment.action,
    model: assessment.model,
    result: assessment.result || 'pending', // 'success', 'failed', 'pending'
    degraded: assessment.degraded || false,
    phases: assessment.phases || {}
  };
  
  // Add to history
  history.assessments.push(record);
  
  // Update statistics
  history.statistics.totalAssessments++;
  if (assessment.action === 'auto-split') history.statistics.autoSplits++;
  if (assessment.action === 'warn') history.statistics.warnings++;
  history.statistics.avgScore = 
    history.assessments.reduce((s, a) => s + a.score, 0) / history.assessments.length;
  history.lastUpdated = record.timestamp;
  
  // Write updated history
  await dc.write_file({ path: historyPath, content: JSON.stringify(history, null, 2) });
  
  // Also record in debug-thinking knowledge graph
  await mcp__debug__debug_thinking({
    action: "create",
    nodeType: "observation",
    content: `Complexity assessment: score=${assessment.score}, action=${assessment.action}`,
    metadata: { score: assessment.score, action: assessment.action, model: assessment.model }
  });
  
  return record;
}

module.exports = { recordAssessment };
```
  </action>
  <verify>recordAssessment adds entry to complexity-history.json and creates debug-thinking node</verify>
  <done>recordAssessment saves assessments to history file and debug-thinking</done>
</task>

<task type="auto">
  <name>Task 3: Implement queryPatterns function</name>
  <files>lib/complexity/learning.js</files>
  <action>
Implement pattern querying that retrieves similar past assessments:

```javascript
async function queryPatterns(criteria = {}) {
  // Query debug-thinking knowledge graph
  const debugPatterns = await mcp__debug__debug_thinking({
    action: "query",
    queryType: "similar-problems",
    parameters: {
      pattern: criteria.pattern || "complexity",
      limit: criteria.limit || 10,
      minSimilarity: criteria.minSimilarity || 0.3
    }
  });
  
  // Also query local history file
  const historyPath = '.planning/complexity-history.json';
  const history = JSON.parse(await dc.read_file({ path: historyPath }));
  
  // Filter by criteria
  let localPatterns = history.assessments;
  if (criteria.minScore) {
    localPatterns = localPatterns.filter(a => a.score >= criteria.minScore);
  }
  if (criteria.action) {
    localPatterns = localPatterns.filter(a => a.action === criteria.action);
  }
  if (criteria.model) {
    localPatterns = localPatterns.filter(a => a.model === criteria.model);
  }
  
  return {
    debugGraph: debugPatterns.results || [],
    localHistory: localPatterns.slice(-20), // Last 20 matching
    combinedCount: (debugPatterns.results?.length || 0) + localPatterns.length
  };
}

module.exports = { recordAssessment, queryPatterns };
```
  </action>
  <verify>queryPatterns returns patterns from both debug-thinking and local history</verify>
  <done>queryPatterns retrieves similar patterns from multiple sources</done>
</task>

<task type="auto">
  <name>Task 4: Implement adaptFromHistory function</name>
  <files>lib/complexity/learning.js</files>
  <action>
Implement learning from history that identifies patterns:

```javascript
async function adaptFromHistory() {
  const historyPath = '.planning/complexity-history.json';
  const history = JSON.parse(await dc.read_file({ path: historyPath }));
  
  // Only adapt if we have enough data
  if (history.assessments.length < 10) {
    return { adapted: false, reason: "Insufficient history for adaptation" };
  }
  
  // Analyze success rates by score ranges
  const scoreRanges = {};
  history.assessments.forEach(a => {
    const range = Math.floor(a.score / 10) * 10; // 0-10, 10-20, etc.
    if (!scoreRanges[range]) {
      scoreRanges[range] = { success: 0, failed: 0, total: 0 };
    }
    scoreRanges[range].total++;
    if (a.result === 'success') scoreRanges[range].success++;
    if (a.result === 'failed') scoreRanges[range].failed++;
  });
  
  // Find problem ranges (high failure rate)
  const problemRanges = Object.entries(scoreRanges)
    .filter(([range, stats]) => stats.failed / stats.total > 0.3)
    .map(([range]) => parseInt(range));
  
  // Calculate success rate
  const successfulAssessments = history.assessments.filter(a => a.result === 'success').length;
  history.statistics.successRate = successfulAssessments / history.assessments.length;
  
  return {
    adapted: problemRanges.length > 0,
    problemRanges,
    successRate: history.statistics.successRate,
    recommendation: problemRanges.length > 0 
      ? `Consider lowering thresholds to avoid score ranges: ${problemRanges.join(', ')}`
      : "Current thresholds performing well"
  };
}

module.exports = { recordAssessment, queryPatterns, adaptFromHistory };
```
  </action>
  <verify>adaptFromHistory analyzes history and returns adaptation recommendations</verify>
  <done>adaptFromHistory identifies problematic score ranges from history</done>
</task>

<task type="auto">
  <name>Task 5: Implement threshold adapter module</name>
  <files>lib/complexity/threshold-adapter.js</files>
  <action>
Create the threshold adapter that adjusts model-specs.json based on learning:

```javascript
const dc = require('../mcp/desktop-commander');
const { adaptFromHistory } = require('./learning');

async function adaptThresholds(modelId) {
  // Get adaptation analysis
  const analysis = await adaptFromHistory();
  
  if (!analysis.adapted) {
    return { adapted: false, reason: analysis.reason || "No adaptation needed" };
  }
  
  // Read current model specs
  const specsPath = '.planning/model-specs.json';
  const specs = JSON.parse(await dc.read_file({ path: specsPath }));
  
  // Adjust thresholds based on problem ranges
  const modelSpec = specs[modelId] || specs['default'];
  const adjustment = -5; // Lower thresholds by 5 points
  
  // Only adjust if problem ranges overlap with current thresholds
  const problemRanges = analysis.problemRanges;
  const currentWarnThreshold = modelSpec.warn_threshold;
  
  if (problemRanges.some(r => r >= currentWarnThreshold - 10 && r <= currentWarnThreshold)) {
    modelSpec.warn_threshold = Math.max(30, modelSpec.warn_threshold + adjustment);
    modelSpec.split_threshold = Math.max(50, modelSpec.split_threshold + adjustment);
    
    // Record adaptation
    const historyPath = '.planning/complexity-history.json';
    const history = JSON.parse(await dc.read_file({ path: historyPath }));
    history.adaptations.push({
      timestamp: new Date().toISOString(),
      modelId,
      oldThresholds: { ...modelSpec },
      newThresholds: { warn_threshold: modelSpec.warn_threshold, split_threshold: modelSpec.split_threshold },
      reason: analysis.recommendation
    });
    
    // Write updated specs
    await dc.write_file({ path: specsPath, content: JSON.stringify(specs, null, 2) });
    await dc.write_file({ path: historyPath, content: JSON.stringify(history, null, 2) });
    
    return {
      adapted: true,
      modelId,
      newThresholds: {
        warn_threshold: modelSpec.warn_threshold,
        split_threshold: modelSpec.split_threshold
      },
      reason: analysis.recommendation
    };
  }
  
  return { adapted: false, reason: "Problem ranges don't overlap with current thresholds" };
}

async function getAdaptedThresholds(modelId) {
  const specsPath = '.planning/model-specs.json';
  const specs = JSON.parse(await dc.read_file({ path: specsPath }));
  return specs[modelId] || specs['default'];
}

module.exports = { adaptThresholds, getAdaptedThresholds };
```
  </action>
  <verify>adaptThresholds adjusts thresholds based on failure patterns</verify>
  <done>threshold-adapter adjusts model-specs.json based on learning</done>
</task>

<task type="auto">
  <name>Task 6: Update index.js with learning exports</name>
  <files>lib/complexity/index.js</files>
  <action>
Update the main index to export all learning functions:

```javascript
const modelAwareness = require('./model-awareness');
const scorer = require('./scorer');
const cognitiveFlow = require('./cognitive-flow');
const tractatusCi = require('./tractatus-ci-phase');
const sequentialCg = require('./sequential-cg-phase');
const debugDc = require('./debug-dc-phase');
const autoSplit = require('./auto-split');
const warningSystem = require('./warning-system');
const learning = require('./learning');
const thresholdAdapter = require('./threshold-adapter');

module.exports = {
  // Layer 1: Model Awareness
  ...modelAwareness,
  
  // Scoring
  ...scorer,
  
  // Layer 2: Cognitive Flow
  runCognitiveFlow: cognitiveFlow.runCognitiveFlow,
  ComplexityResult: cognitiveFlow.ComplexityResult,
  
  // Individual phases
  runStructurePhase: tractatusCi.runStructurePhase,
  runProcessPhase: sequentialCg.runProcessPhase,
  runLearningPhase: debugDc.runLearningPhase,
  
  // Layer 3: Auto-Split Decision
  calculateSubPhaseCount: autoSplit.calculateSubPhaseCount,
  splitPlan: autoSplit.splitPlan,
  executeAutoSplit: autoSplit.executeAutoSplit,
  
  // Warning System
  generateWarning: warningSystem.generateWarning,
  handleUserResponse: warningSystem.handleUserResponse,
  
  // Learning & Adaptation
  recordAssessment: learning.recordAssessment,
  queryPatterns: learning.queryPatterns,
  adaptFromHistory: learning.adaptFromHistory,
  adaptThresholds: thresholdAdapter.adaptThresholds,
  getAdaptedThresholds: thresholdAdapter.getAdaptedThresholds
};
```
  </action>
  <verify>require('./lib/complexity') exports all learning functions</verify>
  <done>Unified index.js exports complete complexity prediction API</done>
</task>

</tasks>

<verification>
Verify Learning & Adaptation completion by:
1. mcp__desktop-commander__read_file(".planning/complexity-history.json") - should contain valid JSON structure
2. mcp__desktop-commander__read_file("lib/complexity/learning.js") - should contain recordAssessment, queryPatterns, adaptFromHistory
3. mcp__desktop-commander__read_file("lib/complexity/threshold-adapter.js") - should contain adaptThresholds, getAdaptedThresholds
4. Learning integrates with debug-thinking knowledge graph
5. Threshold adaptation modifies model-specs.json
</verification>

<success_criteria>
- [ ] complexity-history.json created with tracking structure
- [ ] recordAssessment saves to history and debug-thinking
- [ ] queryPatterns retrieves from debug-thinking and local history
- [ ] adaptFromHistory identifies problematic score ranges
- [ ] adaptThresholds adjusts model-specs.json
- [ ] getAdaptedThresholds retrieves adapted thresholds
- [ ] Unified index.js exports complete API
</success_criteria>

<output>
After completion, create `.planning/phases/17-complexity-prediction/17-05-SUMMARY.md` documenting:
- Assessment recording to history and debug-thinking
- Pattern querying from multiple sources
- History-based adaptation analysis
- Threshold auto-adjustment algorithm
- Integration with Layer 1-3 systems
</output>
