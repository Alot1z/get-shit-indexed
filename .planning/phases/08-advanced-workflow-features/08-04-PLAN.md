---
phase: 08-advanced-workflow-features
plan: 04
type: execute
wave: 4
depends_on: ["08-01", "08-02", "08-03"]
files_modified: ["get-shit-indexed/workflows/map-codebase.md", "get-shit-indexed/workflows/execute-phase.md", ".planning/config.json", "get-shit-indexed/references/wave-verification.md"]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Wave-based spawning prevents API rate limits with verifiable delays"
    - "Rate limiting configuration is adjustable"
    - "Wave execution is logged and trackable"
    - "Failed waves have retry and recovery mechanisms"
  artifacts:
    - path: "get-shit-indexed/references/wave-verification.md"
      provides: "Wave verification and testing documentation"
      min_lines: 100
    - path: ".planning/config.json"
      provides: "Wave configuration storage"
      contains: "rate_limiting"
    - path: "bin/test-wave-spawning.js"
      provides: "Wave spawning test script"
      min_lines: 50
  key_links:
    - from: "map-codebase.md"
      to: "config.json"
      via: "rate limiting configuration"
      pattern: "rate_limiting.*max_concurrent"
    - from: "test-wave-spawning.js"
      to: "agent-history.json"
      via: "spawn verification"
      pattern: "verify.*agent.*spawn"

<tool_priority>
**Tool Selection Hierarchy (MANDATORY):**
1. Skills FIRST (pre-compressed, maximum efficiency)
2. Desktop Commander MCP SECOND (high efficiency)
3. Other MCP Tools THIRD (medium efficiency)
4. Native Tools LAST (fallback only)

**Quick Reference:**
- File ops -> mcp__desktop-commander__*
- Code search -> mcp__code-index-mcp__*
- Process ops -> mcp__desktop-commander__start_process

**See @.planning/codebase/TOOL-PRIORITY-RULES.md for detailed guidance**
</tool_priority>

---

<objective>
Verify wave-based spawning prevents API rate limits through testing and validation.

Purpose: Ensure parallel orchestration safely manages concurrent agent spawns without overwhelming APIs
Output: Verified wave execution with test suite and adjustable rate limiting
</objective>

<execution_context>
@~/.claude/get-shit-indexed\workflows\execute-plan.md
@~/.claude/get-shit-indexed\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@get-shit-indexed/workflows/map-codebase.md
@get-shit-indexed/workflows/execute-phase.md
@.planning/config.json
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create wave-verification.md reference documentation</name>
  <files>get-shit-indexed/references/wave-verification.md</files>
  <action>Create wave verification reference document:

1. Create get-shit-indexed/references/wave-verification.md
2. Document wave architecture:
   - 3-wave structure (independent, dependent, synthesis)
   - Stagger delays between agent spawns
   - Inter-wave delays for API recovery
   - Timeout handling per wave
3. Document rate limiting parameters:
   - max_concurrent_agents: 3 (default)
   - stagger_delay_ms: 500 (default)
   - inter_wave_delay_ms: 2000 (default)
   - wave_timeout_seconds: 300 (default)
4. Include verification checklist and testing procedures

Use mcp__desktop-commander__write_file to create the reference.</action>
  <verify>[ -f get-shit-indexed/references/wave-verification.md ] && grep -c "stagger_delay\|rate_limiting" get-shit-indexed/references/wave-verification.md returns >= 2</verify>
  <done>Wave verification reference with architecture and parameters</done>
</task>

<task type="auto">
  <name>Task 2: Add rate_limiting section to config.json</name>
  <files>.planning/config.json</files>
  <action>Update .planning/config.json with rate limiting configuration:

1. Read existing .planning/config.json to preserve current settings
2. Add rate_limiting section:
   - max_concurrent_agents: 3
   - stagger_delay_ms: 500
   - inter_wave_delay_ms: 2000
   - wave_timeout_seconds: 300
   - adaptive_rate_limiting: true (auto-adjust on errors)
3. Add wave tracking section:
   - log_wave_execution: true
   - wave_log_path: ".planning/wave-history.json"

Use mcp__desktop-commander__read_file then mcp__desktop-commander__edit_block to update.</action>
  <verify>grep -c "rate_limiting\|stagger_delay_ms" .planning/config.json returns >= 2</verify>
  <done>config.json updated with rate limiting and wave tracking settings</done>
</task>

<task type="auto">
  <name>Task 3: Update map-codebase.md to read rate limits from config</name>
  <files>get-shit-indexed/workflows/map-codebase.md</files>
  <action>Update map-codebase.md spawn_agents step to read rate limits from config:

1. Modify spawn_agents step to read from config.json:
   - Read rate_limiting section
   - Use configured values for stagger and timeout
   - Fall back to defaults if config missing
2. Add logging for rate limit values used
3. Document adaptive behavior when adaptive_rate_limiting is true

Use mcp__desktop-commander__edit_block to update spawn_agents step.</action>
  <verify>grep -c "rate_limiting\|config.json" get-shit-indexed/workflows/map-codebase.md returns >= 3</verify>
  <done>map-codebase.md reads rate limiting from config.json</done>
</task>

<task type="auto">
  <name>Task 4: Create wave-history.json logging format</name>
  <files>get-shit-indexed/references/wave-verification.md</files>
  <action>Add wave history logging format to wave-verification.md:

1. Update get-shit-indexed/references/wave-verification.md
2. Document wave-history.json format:
   - version: string
   - waves: array of wave executions
   - Each wave: { wave_number, agents, start_time, end_time, status, errors }
3. Include example wave history entries
4. Document how to read and analyze wave history

Use mcp__desktop-commander__edit_block to add logging format section.</action>
  <verify>grep -c "wave-history\|wave_execution" get-shit-indexed/references/wave-verification.md returns >= 2</verify>
  <done>Wave history logging format documented</done>
</task>

<task type="auto">
  <name>Task 5: Add wave logging to execute-phase.md</name>
  <files>get-shit-indexed/workflows/execute-phase.md</files>
  <action>Add wave logging to execute-phase.md:

1. Add log_wave_execution function:
   - Read log_wave_execution from config
   - Create/update .planning/wave-history.json
   - Log wave start, agents spawned, completion, errors
2. Call logging function in spawn_agents step
3. Include wave status in execution output

Use mcp__desktop-commander__edit_block to add wave logging.</action>
  <verify>grep -c "wave-history\|log_wave" get-shit-indexed/workflows/execute-phase.md returns >= 2</verify>
  <done>Wave logging added to execute-phase.md</done>
</task>

<task type="auto">
  <name>Task 6: Create test-wave-spawning.js test script</name>
  <files>bin/test-wave-spawning.js</files>
  <action>Create wave spawning test script:

1. Create bin/test-wave-spawning.js
2. Implement tests:
   - test_stagger_delay: Verify agents spawn with delays
   - test_max_concurrent: Verify concurrent agent limit
   - test_wave_timeout: Verify timeout handling
   - test_wave_logging: Verify wave-history.json creation
3. Output JSON results with pass/fail per test
4. Include mock agent spawning (no actual agents)

Use mcp__desktop-commander__write_file to create the test script.</action>
  <verify>[ -f bin/test-wave-spawning.js ] && grep -c "test_\|verify" bin/test-wave-spawning.js returns >= 4</verify>
  <done>Wave spawning test script created with 4 tests</done>
</task>

<task type="auto">
  <name>Task 7: Add adaptive rate limiting to map-codebase.md</name>
  <files>get-shit-indexed/workflows/map-codebase.md</files>
  <action>Add adaptive rate limiting behavior to map-codebase.md:

1. Extend spawn_agents step with adaptive behavior:
   - Detect API rate limit errors (429, rate_limit exceeded)
   - On error: increase stagger_delay_ms by 2x
   - Back off max_concurrent_agents by 1
   - Retry failed wave with adjusted settings
2. Document adaptation limits:
   - Max stagger: 5000ms
   - Min concurrent: 1
3. Log adaptations to wave-history.json

Use mcp__desktop-commander__edit_block to add adaptive rate limiting.</action>
  <verify>grep -c "adaptive\|rate_limit.*error" get-shit-indexed/workflows/map-codebase.md returns >= 2</verify>
  <done>Adaptive rate limiting documented and implemented</done>
</task>

<task type="auto">
  <name>Task 8: Create wave-health monitoring script</name>
  <files>bin/wave-health.js</files>
  <action>Create wave health monitoring script:

1. Create bin/wave-health.js
2. Implement health checks:
   - Read wave-history.json
   - Calculate success rate per wave
   - Detect patterns (failing waves, high error rates)
   - Recommend rate limit adjustments
3. Output health report with recommendations
4. Exit codes: 0 (healthy), 1 (warnings), 2 (errors)

Use mcp__desktop-commander__write_file to create the health script.</action>
  <verify>[ -f bin/wave-health.js ] && grep -c "health\|success_rate" bin/wave-health.js returns >= 2</verify>
  <done>Wave health monitoring script created</done>
</task>

<task type="auto">
  <name>Task 9: Add wave verification checkpoint to map-codebase.md</name>
  <files>get-shit-indexed/workflows/map-codebase.md</files>
  <action>Add wave verification checkpoint after spawn_agents:

1. Add verification step after spawn_agents
2. Verify:
   - All agents in wave spawned successfully
   - Stagger delays were applied
   - No rate limit errors occurred
   - wave-history.json updated
3. On failure: recommend rate limit adjustment
4. Log verification results

Use mcp__desktop-commander__edit_block to add verification step.</action>
  <verify>grep -c "wave.*verif\|verify.*wave" get-shit-indexed/workflows/map-codebase.md returns >= 1</verify>
  <done>Wave verification checkpoint added after spawn_agents</done>
</task>

<task type="auto">
  <name>Task 10: Create wave configuration tuning guide</name>
  <files>get-shit-indexed/references/wave-tuning.md</files>
  <action>Create wave configuration tuning guide:

1. Create get-shit-indexed/references/wave-tuning.md
2. Document tuning scenarios:
   - High-speed environments: increase max_concurrent, reduce stagger
   - Rate-limited APIs: decrease max_concurrent, increase stagger
   - Unstable networks: increase timeout, enable adaptive
3. Include decision matrix for tuning
4. Document trade-offs and risks
5. Provide example configurations for different scenarios

Use mcp__desktop-commander__write_file to create the tuning guide.</action>
  <verify>[ -f get-shit-indexed/references/wave-tuning.md ] && grep -c "tuning\|max_concurrent\|stagger" get-shit-indexed/references/wave-tuning.md returns >= 3</verify>
  <done>Wave tuning guide created with scenarios and examples</done>
</task>

</tasks>

<verification>
1. wave-verification.md exists with architecture documentation
2. config.json has rate_limiting section with all parameters
3. map-codebase.md reads rate limits from config
4. Wave history logging format documented
5. execute-phase.md includes wave logging
6. test-wave-spawning.js created with 4 tests
7. Adaptive rate limiting documented in map-codebase.md
8. wave-health.js monitoring script created
9. Wave verification checkpoint added to map-codebase.md
10. Wave tuning guide created
11. All changes use MCP tools
</verification>

<success_criteria>
1. Wave-based spawning is fully documented and testable
2. Rate limiting is configurable via config.json
3. Adaptive rate limiting responds to API errors
4. Wave execution is logged to wave-history.json
5. Test suite verifies wave behavior
6. Health monitoring detects issues
7. Tuning guide helps optimize for different environments
8. Tool priority maintained (MCP tools throughout)
</success_criteria>

<output>
After completion, create `.planning/phases/08-advanced-workflow-features/08-04-SUMMARY.md`
</output>
