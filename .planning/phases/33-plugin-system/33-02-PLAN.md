---
phase: 33
plan: 02
title: Plugin Lifecycle
wave: 1
depends_on: [33-01]
files_modified:
  - lib/gsi-core/plugins/lifecycle-manager.ts
  - lib/gsi-core/plugins/plugin-state.ts
autonomous: true
must_haves:
  truths:
    - Plugins load/unload safely
    - State transitions managed
    - Dependencies resolved
  artifacts:
    - lib/gsi-core/plugins/lifecycle-manager.ts:150
    - lib/gsi-core/plugins/plugin-state.ts:60
---

# 33-02: Plugin Lifecycle

## Objective
Implement plugin lifecycle management for safe loading and unloading.

## Tasks

### Task 1: Lifecycle Manager
**File**: `lib/gsi-core/plugins/lifecycle-manager.ts`
**Lines**: ~150

```typescript
import { PluginState, StateTransition } from './plugin-state.js';
import type { GSIPlugin, PluginContext } from './types.js';

export class LifecycleManager {
  private plugins: Map<string, { plugin: GSIPlugin; state: PluginState }> = new Map();
  private context: PluginContext;

  constructor(context: PluginContext) {
    this.context = context;
  }

  /**
   * Load and initialize a plugin
   */
  async load(name: string, plugin: GSIPlugin): Promise<void> {
    if (this.plugins.has(name)) {
      throw new Error(`Plugin already loaded: ${name}`);
    }

    // Create state machine
    const state = new PluginState();

    // Transition to loading
    state.transition(StateTransition.LOAD);

    try {
      // Call plugin init
      await plugin.init(this.context);

      // Transition to loaded
      state.transition(StateTransition.INITIALIZE);
      state.transition(StateTransition.ENABLE);

      // Store plugin
      this.plugins.set(name, { plugin, state });

    } catch (error) {
      state.transition(StateTransition.FAIL);
      throw error;
    }
  }

  /**
   * Unload a plugin
   */
  async unload(name: string): Promise<void> {
    const entry = this.plugins.get(name);
    if (!entry) {
      throw new Error(`Plugin not found: ${name}`);
    }

    const { plugin, state } = entry;

    // Transition to disabling
    state.transition(StateTransition.DISABLE);
    state.transition(StateTransition.UNINITIALIZE);

    try {
      // Call plugin cleanup
      await plugin.cleanup();

      // Transition to unloaded
      state.transition(StateTransition.UNLOAD);

      // Remove plugin
      this.plugins.delete(name);

    } catch (error) {
      state.transition(StateTransition.FAIL);
      throw error;
    }
  }

  /**
   * Enable a disabled plugin
   */
  async enable(name: string): Promise<void> {
    const entry = this.plugins.get(name);
    if (!entry) throw new Error(`Plugin not found: ${name}`);

    entry.state.transition(StateTransition.ENABLE);
    await entry.plugin.enable?.();
  }

  /**
   * Disable an enabled plugin
   */
  async disable(name: string): Promise<void> {
    const entry = this.plugins.get(name);
    if (!entry) throw new Error(`Plugin not found: ${name}`);

    entry.state.transition(StateTransition.DISABLE);
    await entry.plugin.disable?.();
  }

  /**
   * Get plugin state
   */
  getState(name: string): string {
    return this.plugins.get(name)?.state.current ?? 'not_found';
  }

  /**
   * List all plugins with states
   */
  listAll(): Array<{ name: string; state: string }> {
    return Array.from(this.plugins.entries()).map(([name, entry]) => ({
      name,
      state: entry.state.current
    }));
  }
}
```

### Task 2: Plugin State Machine
**File**: `lib/gsi-core/plugins/plugin-state.ts`
**Lines**: ~60

```typescript
export enum PluginStatus {
  UNLOADED = 'unloaded',
  LOADING = 'loading',
  LOADED = 'loaded',
  ENABLING = 'enabling',
  ENABLED = 'enabled',
  DISABLING = 'disabling',
  DISABLED = 'disabled',
  FAILED = 'failed'
}

export enum StateTransition {
  LOAD = 'load',
  INITIALIZE = 'initialize',
  ENABLE = 'enable',
  DISABLE = 'disable',
  UNINITIALIZE = 'uninitialize',
  UNLOAD = 'unload',
  FAIL = 'fail'
}

export class PluginState {
  current: PluginStatus = PluginStatus.UNLOADED;

  private transitions: Record<PluginStatus, Record<StateTransition, PluginStatus>> = {
    [PluginStatus.UNLOADED]: {
      [StateTransition.LOAD]: PluginStatus.LOADING
    },
    [PluginStatus.LOADING]: {
      [StateTransition.INITIALIZE]: PluginStatus.LOADED,
      [StateTransition.FAIL]: PluginStatus.FAILED
    },
    [PluginStatus.LOADED]: {
      [StateTransition.ENABLE]: PluginStatus.ENABLING
    },
    [PluginStatus.ENABLING]: {
      [StateTransition.ENABLE]: PluginStatus.ENABLED,
      [StateTransition.FAIL]: PluginStatus.FAILED
    },
    [PluginStatus.ENABLED]: {
      [StateTransition.DISABLE]: PluginStatus.DISABLING
    },
    [PluginStatus.DISABLING]: {
      [StateTransition.DISABLE]: PluginStatus.DISABLED,
      [StateTransition.UNINITIALIZE]: PluginStatus.LOADED
    },
    [PluginStatus.DISABLED]: {
      [StateTransition.ENABLE]: PluginStatus.ENABLING,
      [StateTransition.UNINITIALIZE]: PluginStatus.LOADED
    },
    [PluginStatus.FAILED]: {
      [StateTransition.UNLOAD]: PluginStatus.UNLOADED
    }
  };

  transition(action: StateTransition): void {
    const next = this.transitions[this.current]?.[action];
    if (!next) {
      throw new Error(`Invalid transition: ${this.current} -> ${action}`);
    }
    this.current = next;
  }
}
```

## Output
- Lifecycle manager for plugins
- State machine for safe transitions
- Enable/disable support

**Next**: 33-03 - Plugin Discovery
