---
phase: 33
plan: 06
title: Plugin Dependencies
wave: 2
depends_on: [33-05]
files_modified:
  - lib/gsi-core/plugins/dependency-resolver.ts
  - lib/gsi-core/plugins/version-checker.ts
autonomous: true
must_haves:
  truths:
    - Dependencies resolved
    - Versions checked
    - Load order correct
  artifacts:
    - lib/gsi-core/plugins/dependency-resolver.ts:140
    - lib/gsi-core/plugins/version-checker.ts:60
---

# 33-06: Plugin Dependencies

## Objective
Implement plugin dependency resolution and version checking.

## Tasks

### Task 1: Dependency Resolver
**File**: `lib/gsi-core/plugins/dependency-resolver.ts`
**Lines**: ~140

```typescript
import type { PluginManifest } from './types.js';

export interface ResolvedPlugin {
  name: string;
  manifest: PluginManifest;
  dependencies: string[];
}

export class DependencyResolver {
  private plugins: Map<string, PluginManifest> = new Map();

  /**
   * Register a plugin manifest
   */
  register(name: string, manifest: PluginManifest): void {
    this.plugins.set(name, manifest);
  }

  /**
   * Resolve load order for plugins
   */
  resolve(pluginNames: string[]): string[] {
    const resolved: string[] = [];
    const visiting: Set<string> = new Set();
    const visited: Set<string> = new Set();

    for (const name of pluginNames) {
      this.visit(name, resolved, visiting, visited);
    }

    return resolved;
  }

  /**
   * Visit plugin for topological sort
   */
  private visit(
    name: string,
    resolved: string[],
    visiting: Set<string>,
    visited: Set<string>
  ): void {
    if (visited.has(name)) return;
    if (visiting.has(name)) {
      throw new Error(`Circular dependency detected: ${name}`);
    }

    visiting.add(name);

    const manifest = this.plugins.get(name);
    if (manifest?.dependencies) {
      for (const dep of Object.keys(manifest.dependencies)) {
        this.visit(dep, resolved, visiting, visited);
      }
    }

    visiting.delete(name);
    visited.add(name);
    resolved.push(name);
  }

  /**
   * Check for missing dependencies
   */
  checkMissing(pluginNames: string[]): string[] {
    const missing: string[] = [];

    for (const name of pluginNames) {
      const manifest = this.plugins.get(name);
      if (manifest?.dependencies) {
        for (const dep of Object.keys(manifest.dependencies)) {
          if (!this.plugins.has(dep)) {
            missing.push(`${name} requires ${dep}`);
          }
        }
      }
    }

    return missing;
  }

  /**
   * Get dependency graph
   */
  getGraph(): Map<string, string[]> {
    const graph = new Map<string, string[]>();

    for (const [name, manifest] of this.plugins.entries()) {
      graph.set(name, manifest.dependencies ? Object.keys(manifest.dependencies) : []);
    }

    return graph;
  }
}
```

### Task 2: Version Checker
**File**: `lib/gsi-core/plugins/version-checker.ts`
**Lines**: ~60

```typescript
import * as semver from 'semver';

export interface VersionCheck {
  valid: boolean;
  errors: string[];
}

export class VersionChecker {
  /**
   * Check if version satisfies constraint
   */
  satisfies(version: string, constraint: string): boolean {
    return semver.satisfies(version, constraint);
  }

  /**
   * Check plugin dependencies versions
   */
  check(
    pluginName: string,
    pluginVersion: string,
    dependencies: Record<string, string>,
    installed: Map<string, string>
  ): VersionCheck {
    const errors: string[] = [];

    for (const [dep, constraint] of Object.entries(dependencies)) {
      const installedVersion = installed.get(dep);

      if (!installedVersion) {
        errors.push(`Missing dependency: ${dep}`);
        continue;
      }

      if (!this.satisfies(installedVersion, constraint)) {
        errors.push(
          `${dep}@${installedVersion} does not satisfy ${constraint} (required by ${pluginName})`
        );
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }
}
```

## Output
- Topological dependency resolution
- Circular dependency detection
- Semver version checking

**Next**: 33-07 - Plugin Isolation
