---
phase: 33
plan: 03
title: Plugin Discovery
wave: 1
depends_on: [33-01]
files_modified:
  - lib/gsi-core/plugins/plugin-discovery.ts
  - lib/gsi-core/plugins/plugin-validator.ts
autonomous: true
must_haves:
  truths:
    - Plugins discovered automatically
    - Manifest validated
    - Invalid plugins rejected
  artifacts:
    - lib/gsi-core/plugins/plugin-discovery.ts:120
    - lib/gsi-core/plugins/plugin-validator.ts:100
---

# 33-03: Plugin Discovery

## Objective
Implement automatic plugin discovery and validation.

## Tasks

### Task 1: Plugin Discovery
**File**: `lib/gsi-core/plugins/plugin-discovery.ts`
**Lines**: ~120

```typescript
import { PluginValidator } from './plugin-validator.js';
import type { PluginManifest } from './types.js';
import * as path from 'path';
import * as fs from 'fs/promises';

export class PluginDiscovery {
  private validator: PluginValidator;
  private searchPaths: string[];

  constructor(searchPaths: string[] = []) {
    this.validator = new PluginValidator();
    this.searchPaths = searchPaths.length > 0 
      ? searchPaths 
      : [path.join(process.cwd(), 'plugins')];
  }

  /**
   * Add a search path for plugins
   */
  addSearchPath(path: string): void {
    this.searchPaths.push(path);
  }

  /**
   * Discover all valid plugins
   */
  async discover(): Promise<Array<{ path: string; manifest: PluginManifest }>> {
    const discovered: Array<{ path: string; manifest: PluginManifest }> = [];

    for (const searchPath of this.searchPaths) {
      const plugins = await this.scanDirectory(searchPath);
      discovered.push(...plugins);
    }

    return discovered;
  }

  /**
   * Scan directory for plugins
   */
  private async scanDirectory(dir: string): Promise<Array<{ path: string; manifest: PluginManifest }>> {
    const results: Array<{ path: string; manifest: PluginManifest }> = [];

    try {
      const entries = await fs.readdir(dir, { withFileTypes: true });

      for (const entry of entries) {
        if (!entry.isDirectory()) continue;

        const pluginPath = path.join(dir, entry.name);
        const manifest = await this.tryLoadManifest(pluginPath);

        if (manifest) {
          const validation = this.validator.validate(manifest);
          if (validation.valid) {
            results.push({ path: pluginPath, manifest });
          } else {
            console.warn(`Invalid plugin manifest at ${pluginPath}:`, validation.errors);
          }
        }
      }
    } catch (error) {
      // Directory doesn't exist or not accessible
      if ((error as NodeJS.ErrnoException).code !== 'ENOENT') {
        throw error;
      }
    }

    return results;
  }

  /**
   * Try to load plugin manifest
   */
  private async tryLoadManifest(pluginPath: string): Promise<PluginManifest | null> {
    const manifestPath = path.join(pluginPath, 'plugin.yaml');

    try {
      const content = await fs.readFile(manifestPath, 'utf-8');
      // Parse YAML (using yaml library)
      const yaml = await import('yaml');
      return yaml.parse(content) as PluginManifest;
    } catch {
      return null;
    }
  }
}
```

### Task 2: Plugin Validator
**File**: `lib/gsi-core/plugins/plugin-validator.ts`
**Lines**: ~100

```typescript
import type { PluginManifest } from './types.js';

export interface ValidationResult {
  valid: boolean;
  errors: string[];
}

export class PluginValidator {
  private requiredFields = ['name', 'version', 'main'];
  private validVersions = ['1.0'];

  /**
   * Validate plugin manifest
   */
  validate(manifest: PluginManifest): ValidationResult {
    const errors: string[] = [];

    // Check required fields
    for (const field of this.requiredFields) {
      if (!(field in manifest)) {
        errors.push(`Missing required field: ${field}`);
      }
    }

    // Validate name format
    if (manifest.name && !this.isValidName(manifest.name)) {
      errors.push('Invalid plugin name (must be lowercase, alphanumeric with dashes)');
    }

    // Validate version format
    if (manifest.version && !this.isValidVersion(manifest.version)) {
      errors.push('Invalid version format (must be semver)');
    }

    // Validate API version
    if (manifest.apiVersion && !this.validVersions.includes(manifest.apiVersion)) {
      errors.push(`Unsupported API version: ${manifest.apiVersion}`);
    }

    // Validate dependencies
    if (manifest.dependencies) {
      for (const [dep, version] of Object.entries(manifest.dependencies)) {
        if (!this.isValidName(dep)) {
          errors.push(`Invalid dependency name: ${dep}`);
        }
      }
    }

    return {
      valid: errors.length === 0,
      errors
    };
  }

  private isValidName(name: string): boolean {
    return /^[a-z][a-z0-9-]*$/.test(name);
  }

  private isValidVersion(version: string): boolean {
    return /^\d+\.\d+\.\d+(-[\w.]+)?$/.test(version);
  }
}
```

## Output
- Plugin discovery from directories
- Manifest validation
- Automatic plugin scanning

**Next**: 33-04 - Plugin Configuration
