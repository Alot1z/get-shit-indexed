---
phase: 33
plan: 05
title: Plugin Hooks
wave: 2
depends_on: [33-04]
files_modified:
  - lib/gsi-core/plugins/plugin-hooks.ts
  - lib/gsi-core/plugins/hook-executor.ts
autonomous: true
must_haves:
  truths:
    - Plugins can register hooks
    - Hooks executed in order
    - Results aggregated
  artifacts:
    - lib/gsi-core/plugins/plugin-hooks.ts:100
    - lib/gsi-core/plugins/hook-executor.ts:120
---

# 33-05: Plugin Hooks

## Objective
Implement plugin hook system for extensibility.

## Tasks

### Task 1: Plugin Hooks Registry
**File**: `lib/gsi-core/plugins/plugin-hooks.ts`
**Lines**: ~100

```typescript
export type HookCallback<T = unknown> = (context: T) => Promise<T> | T;

export interface HookEntry {
  plugin: string;
  priority: number;
  callback: HookCallback;
}

export class PluginHooks {
  private hooks: Map<string, HookEntry[]> = new Map();

  /**
   * Register a hook
   */
  register(event: string, plugin: string, callback: HookCallback, priority: number = 100): void {
    const entries = this.hooks.get(event) ?? [];
    entries.push({ plugin, priority, callback });
    entries.sort((a, b) => a.priority - b.priority);
    this.hooks.set(event, entries);
  }

  /**
   * Unregister all hooks for a plugin
   */
  unregister(plugin: string): void {
    for (const [event, entries] of this.hooks.entries()) {
      const filtered = entries.filter(e => e.plugin !== plugin);
      if (filtered.length > 0) {
        this.hooks.set(event, filtered);
      } else {
        this.hooks.delete(event);
      }
    }
  }

  /**
   * Get hooks for an event
   */
  get(event: string): HookEntry[] {
    return this.hooks.get(event) ?? [];
  }

  /**
   * Check if event has hooks
   */
  has(event: string): boolean {
    const entries = this.hooks.get(event);
    return entries !== undefined && entries.length > 0;
  }

  /**
   * List all registered events
   */
  listEvents(): string[] {
    return Array.from(this.hooks.keys());
  }
}
```

### Task 2: Hook Executor
**File**: `lib/gsi-core/plugins/hook-executor.ts`
**Lines**: ~120

```typescript
import { PluginHooks, HookEntry } from './plugin-hooks.js';

export interface HookResult<T> {
  result: T;
  executedBy: string[];
  errors: Array<{ plugin: string; error: Error }>;
}

export class HookExecutor {
  private hooks: PluginHooks;

  constructor(hooks: PluginHooks) {
    this.hooks = hooks;
  }

  /**
   * Execute hooks for an event (sequential)
   */
  async executeSequential<T>(event: string, initialContext: T): Promise<HookResult<T>> {
    const entries = this.hooks.get(event);
    const executedBy: string[] = [];
    const errors: Array<{ plugin: string; error: Error }> = [];

    let context = initialContext;

    for (const entry of entries) {
      try {
        context = await entry.callback(context);
        executedBy.push(entry.plugin);
      } catch (error) {
        errors.push({
          plugin: entry.plugin,
          error: error instanceof Error ? error : new Error(String(error))
        });
        // Continue with next hook
      }
    }

    return { result: context, executedBy, errors };
  }

  /**
   * Execute hooks for an event (parallel)
   */
  async executeParallel<T>(event: string, context: T): Promise<HookResult<T>[]> {
    const entries = this.hooks.get(event);
    const results: HookResult<T>[] = [];

    const promises = entries.map(async (entry) => {
      try {
        const result = await entry.callback(context);
        return {
          result: result as T,
          executedBy: [entry.plugin],
          errors: []
        };
      } catch (error) {
        return {
          result: context,
          executedBy: [],
          errors: [{
            plugin: entry.plugin,
            error: error instanceof Error ? error : new Error(String(error))
          }]
        };
      }
    });

    return Promise.all(promises);
  }

  /**
   * Execute hooks with early termination
   */
  async executeUntil<T>(event: string, context: T, predicate: (result: T) => boolean): Promise<HookResult<T>> {
    const entries = this.hooks.get(event);
    const executedBy: string[] = [];
    const errors: Array<{ plugin: string; error: Error }> = [];

    let current = context;

    for (const entry of entries) {
      try {
        current = await entry.callback(current);
        executedBy.push(entry.plugin);

        if (predicate(current)) {
          break;
        }
      } catch (error) {
        errors.push({
          plugin: entry.plugin,
          error: error instanceof Error ? error : new Error(String(error))
        });
      }
    }

    return { result: current, executedBy, errors };
  }
}
```

## Output
- Plugin hooks registry
- Sequential and parallel execution
- Error handling in hook chains

**Next**: 33-06 - Plugin Dependencies
