---
phase: 33
plan: 07
title: Plugin Isolation
wave: 3
depends_on: [33-06]
files_modified:
  - lib/gsi-core/plugins/sandbox.ts
  - lib/gsi-core/plugins/permission-manager.ts
autonomous: true
must_haves:
  truths:
    - Plugins isolated
    - Permissions enforced
    - Security maintained
  artifacts:
    - lib/gsi-core/plugins/sandbox.ts:120
    - lib/gsi-core/plugins/permission-manager.ts:80
---

# 33-07: Plugin Isolation

## Objective
Implement plugin isolation and security sandboxing.

## Tasks

### Task 1: Plugin Sandbox
**File**: `lib/gsi-core/plugins/sandbox.ts`
**Lines**: ~120

```typescript
import { PermissionManager, Permission } from './permission-manager.js';

export interface SandboxOptions {
  timeout: number;
  memoryLimit: number;
  permissions: Permission[];
}

export class PluginSandbox {
  private permissionManager: PermissionManager;
  private options: SandboxOptions;

  constructor(options: Partial<SandboxOptions> = {}) {
    this.options = {
      timeout: options.timeout ?? 30000,
      memoryLimit: options.memoryLimit ?? 100 * 1024 * 1024, // 100MB
      permissions: options.permissions ?? []
    };
    this.permissionManager = new PermissionManager();
  }

  /**
   * Execute code in sandbox
   */
  async execute<T>(
    pluginName: string,
    fn: () => Promise<T>,
    requiredPermissions: Permission[] = []
  ): Promise<T> {
    // Check permissions
    for (const perm of requiredPermissions) {
      if (!this.permissionManager.hasPermission(this.options.permissions, perm)) {
        throw new Error(`Plugin ${pluginName} lacks permission: ${perm}`);
      }
    }

    // Execute with timeout
    return this.executeWithTimeout(fn, this.options.timeout);
  }

  /**
   * Execute with timeout
   */
  private async executeWithTimeout<T>(fn: () => Promise<T>, timeout: number): Promise<T> {
    return new Promise((resolve, reject) => {
      const timer = setTimeout(() => {
        reject(new Error('Plugin execution timeout'));
      }, timeout);

      fn()
        .then(result => {
          clearTimeout(timer);
          resolve(result);
        })
        .catch(error => {
          clearTimeout(timer);
          reject(error);
        });
    });
  }

  /**
   * Create isolated context
   */
  createContext(pluginName: string): PluginContext {
    return {
      pluginName,
      fs: this.createProxiedFS(pluginName),
      fetch: this.createProxiedFetch(pluginName),
      log: (message: string) => console.log(`[${pluginName}] ${message}`)
    };
  }

  /**
   * Create proxied filesystem access
   */
  private createProxiedFS(pluginName: string): Partial<typeof import('fs/promises')> {
    // Return limited filesystem access
    return {
      readFile: async (path: string) => {
        this.permissionManager.checkFSAccess(this.options.permissions, path, 'read');
        return import('fs/promises').then(fs => fs.readFile(path));
      }
    };
  }

  /**
   * Create proxied fetch
   */
  private createProxiedFetch(pluginName: string): typeof fetch {
    return async (url: string | URL | Request, init?: RequestInit) => {
      this.permissionManager.checkNetworkAccess(this.options.permissions, url.toString());
      return fetch(url, init);
    };
  }
}

export interface PluginContext {
  pluginName: string;
  fs: Partial<typeof import('fs/promises')>;
  fetch: typeof fetch;
  log: (message: string) => void;
}
```

### Task 2: Permission Manager
**File**: `lib/gsi-core/plugins/permission-manager.ts`
**Lines**: ~80

```typescript
export type Permission =
  | 'fs.read'
  | 'fs.write'
  | 'network.http'
  | 'network.https'
  | 'process.spawn'
  | 'env.read';

export class PermissionManager {
  /**
   * Check if permission is granted
   */
  hasPermission(granted: Permission[], required: Permission): boolean {
    return granted.includes(required);
  }

  /**
   * Check filesystem access
   */
  checkFSAccess(permissions: Permission[], path: string, mode: 'read' | 'write'): void {
    const perm = mode === 'read' ? 'fs.read' : 'fs.write';
    if (!this.hasPermission(permissions, perm)) {
      throw new Error(`Permission denied: ${perm} for ${path}`);
    }
  }

  /**
   * Check network access
   */
  checkNetworkAccess(permissions: Permission[], url: string): void {
    const isHttps = url.startsWith('https://');
    const perm = isHttps ? 'network.https' : 'network.http';

    if (!this.hasPermission(permissions, perm)) {
      throw new Error(`Permission denied: ${perm} for ${url}`);
    }
  }

  /**
   * Parse permission string
   */
  parse(permission: string): Permission | null {
    const valid: Permission[] = [
      'fs.read', 'fs.write',
      'network.http', 'network.https',
      'process.spawn', 'env.read'
    ];
    return valid.includes(permission as Permission) ? permission as Permission : null;
  }
}
```

## Output
- Plugin sandbox with timeout
- Permission-based access control
- Isolated execution context

**Next**: 33-08 - Plugin Testing
