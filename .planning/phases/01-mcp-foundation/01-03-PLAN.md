---
phase: 01-mcp-foundation
plan: 03
type: execute
wave: 3
depends_on: [01-01, 01-02]
files_modified: [.planning/codebase/TOOL-PRIORITY-RULES.md, .planning/templates/plan-template.md, workflows/execute-plan.md]
autonomous: true
user_setup: []

must_haves:
  truths:
    - "Tool priority hierarchy (Skills > MCP > Native) is enforced across all GSI operations"
    - "Token efficiency data (80-90% savings) justifies MCP > Native rule"
    - "Plan templates include tool_priority guidance"
    - "execute-plan.md enforces MCP tool requirements"
    - "Decision tree enables optimal tool selection"
    - "All 3 MCP servers (DC, CI, CG) integrated into priority rules"
  artifacts:
    - path: ".planning/codebase/TOOL-PRIORITY-RULES.md"
      provides: "Comprehensive tool priority rules with Skills > MCP > Native hierarchy"
      min_lines: 150
      contains: ["Skills FIRST", "MCP SECOND", "Native LAST", "80%", "90%", "Desktop Commander", "Code-Index", "CodeGraphContext"]
    - path: ".planning/templates/plan-template.md"
      provides: "Plan template with tool_priority section"
      min_lines: 50
      contains: ["tool_priority", "Skills > MCP > Native", "MCP tools"]
    - path: "workflows/execute-plan.md"
      provides: "Workflow enforcing MCP tool requirements"
      contains: ["tool_requirements", "mcp__desktop-commander__", "mcp__code-index-mcp__"]
  key_links:
    - from: "MCP-TOKEN-BENCHMARK.md"
      to: "TOOL-PRIORITY-RULES.md"
      via: "Token efficiency data justifies priority hierarchy"
      pattern: "80.*90.*savings|token.*efficiency"
    - from: "TOOL-PRIORITY-RULES.md"
      to: "plan-template.md"
      via: "Template includes tool_priority guidance"
      pattern: "tool_priority.*section"
    - from: "TOOL-PRIORITY-RULES.md"
      to: "execute-plan.md"
      via: "Workflow enforces tool requirements"
      pattern: "tool_requirements.*mcp"
---

<objective>
Establish comprehensive tool priority rules enforcing Skills > MCP > Native hierarchy across all GSI workflows, with 80-90% token efficiency data driving the enforcement.

Purpose: Ensure all GSI operations use optimal tools (Skills first, MCP second, Native last) for maximum token efficiency
Output: TOOL-PRIORITY-RULES.md with comprehensive hierarchy, plan template with tool_priority, execute-plan.md enforcement
</objective>

<execution_context>
@~/.claude/get-shit-indexed\workflows\execute-plan.md
@~/.claude/get-shit-indexed\templates\summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/codebase/MCP-TOKEN-BENCHMARK.md

Token Efficiency: 80-90% savings for MCP tools vs native (from 01-01)
CG Server: neo4j://localhost:7687 (now integrated)
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create TOOL-PRIORITY-RULES.md with hierarchy definition</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Create TOOL-PRIORITY-RULES.md with tool priority hierarchy:

1. Define hierarchy:
   - Skills FIRST (80-90% token savings)
   - Desktop Commander MCP SECOND (50-70% token savings)
   - Other MCP tools THIRD (30-50% token savings)
   - Native tools LAST (0% token savings)
2. Document why this order:
   - Reference MCP-TOKEN-BENCHMARK.md data
   - Token efficiency per tool level
   - Protocol overhead differences
3. Include decision tree:
   - Need operation? -> Skill available? -> Use Skill
   -> No skill? -> MCP available? -> Use MCP
   -> No MCP? -> Use Native (last resort)

Create comprehensive foundation section (80+ lines).</action>
  <verify>TOOL-PRIORITY-RULES.md exists with Skills > MCP > Native hierarchy and decision tree</verify>
  <done>Tool priority hierarchy defined</done>
</task>

<task type="auto">
  <name>Task 2: Document Desktop Commander MCP rules</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add Desktop Commander (DC) MCP rules to TOOL-PRIORITY-RULES.md:

1. Append DC-specific rules:
   - DC is PRIMARY for all file/process operations
   - DC tools replace: Read, Write, Edit, Bash (file ops), Grep/Glob (search ops)
   - File operations: read_file, write_file, edit_block, list_directory
   - Process operations: start_process, interact_with_process, list_processes
   - Search operations: start_search (files and content)
   - Token savings: 85-90% for file operations
2. Include CORRECT vs WRONG examples:
   - WRONG: Read tool for file reading
   - CORRECT: mcp__desktop-commander__read_file
   - WRONG: Bash for ls/cat
   - CORRECT: mcp__desktop-commander__list_directory

DC rules provide concrete examples for common operations.</action>
  <verify>TOOL-PRIORITY-RULES.md has DC section with file/process/search rules and correct/wrong examples</verify>
  <done>Desktop Commander MCP rules documented</done>
</task>

<task type="auto">
  <name>Task 3: Document Code-Index MCP rules</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add Code-Index (CI) MCP rules to TOOL-PRIORITY-RULES.md:

1. Append CI-specific rules:
   - CI is PRIMARY for code search/symbol navigation
   - CI tools replace: Grep (code search), Glob (file search)
   - Search operations: search_code_advanced (indexed search)
   - File operations: find_files (glob-style patterns)
   - Symbol operations: get_symbol_body, get_file_summary
   - Index operations: build_deep_index, refresh_index
   - Token savings: 80-81% for code search
2. Include CORRECT vs WRONG examples:
   - WRONG: Grep tool for code search
   - CORRECT: mcp__code-index-mcp__search_code_advanced
   - WRONG: Glob for file finding
   - CORRECT: mcp__code-index-mcp__find_files

CI rules show when to use indexed search vs native.</action>
  <verify>TOOL-PRIORITY-RULES.md has CI section with search/symbol rules and correct/wrong examples</verify>
  <done>Code-Index MCP rules documented</done>
</task>

<task type="auto">
  <name>Task 4: Document CodeGraphContext MCP rules</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add CodeGraphContext (CG) MCP rules to TOOL-PRIORITY-RULES.md:

1. Append CG-specific rules:
   - CG is PRIMARY for relationship analysis
   - CG server: neo4j://localhost:7687
   - CG provides: Code graph queries, relationship discovery, dependency analysis
   - CG tools replace: Manual multi-file analysis, complex search patterns
   - Use CG for: Finding all callers/callees, data flow analysis, circular dependencies
   - Token savings: Significant for complex relationship queries
2. Include CORRECT vs WRONG examples:
   - WRONG: Multiple Grep searches to find relationships
   - CORRECT: Single CG relationship query
   - WRONG: Manual trace of function calls
   - CORRECT: CG code graph query

CG rules show efficiency gains for relationship-aware workflows.</action>
  <verify>TOOL-PRIORITY-RULES.md has CG section with neo4j://localhost:7687 and relationship analysis rules</verify>
  <done>CodeGraphContext MCP rules documented</done>
</task>

<task type="auto">
  <name>Task 5: Create tool selection matrix</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add comprehensive tool selection matrix to TOOL-PRIORITY-RULES.md:

1. Create matrix table:
   - Operation type | Skill | MCP (DC/CI/CG) | Native | Use
   - File read | desktop-commander | read_file | Read | Skill
   - File write | desktop-commander | write_file | Write | Skill
   - File search | - | start_search (DC) | Bash | MCP
   - Code search | - | search_code_advanced (CI) | Grep | MCP
   - Symbols | - | get_symbol_body (CI) | Manual | MCP
   - Relationships | - | CG query | Manual analysis | MCP
   - Process | desktop-commander | start_process | Bash | Skill
2. Document decision criteria for each row

Matrix provides quick reference for tool selection.</action>
  <verify>TOOL-PRIORITY-RULES.md has tool selection matrix with operation types and recommended tools</verify>
  <done>Tool selection matrix created</done>
</task>

<task type="auto">
  <name>Task 6: Add batching and optimization guidelines</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add batching and token optimization guidelines:

1. Append to TOOL-PRIORITY-RULES.md:
   - Batching benefits:
     * read_multiple_files vs multiple read_file calls
     * Batch search patterns vs sequential searches
   - Optimization strategies:
     * Use most specific tool available
     * Prefer indexed search (CI) over content search
     * Batch operations when possible
   - Token savings calculations:
     * Show formula: (Native tokens - MCP tokens) / Native tokens
     * Include examples from MCP-TOKEN-BENCHMARK.md
   - Monitoring: How to track token usage per operation

Batching guidelines maximize token efficiency.</action>
  <verify>TOOL-PRIORITY-RULES.md has batching section with optimization strategies and savings calculations</verify>
  <done>Batching and optimization guidelines added</done>
</task>

<task type="auto">
  <name>Task 7: Document enforcement and compliance</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add enforcement and compliance tracking:

1. Append to TOOL-PRIORITY-RULES.md:
   - Enforcement mechanisms:
     * Plan templates include tool_priority section
     * execute-plan.md enforces MCP tool requirements
     * Code review checks for native tool usage
   - Compliance tracking:
     * How to measure MCP vs native usage
     * Token efficiency goals (80-90% savings)
     * Regular audit procedures
   - Anti-patterns to avoid:
     * Using native tools when MCP available
     * Ignoring batching opportunities
     * Not checking for skill equivalents

Enforcement ensures rules are followed consistently.</action>
  <verify>TOOL-PRIORITY-RULES.md has enforcement section with compliance tracking and anti-patterns</verify>
  <done>Enforcement and compliance documented</done>
</task>

<task type="auto">
  <name>Task 8: Add quick reference card</name>
  <files>.planning/codebase/TOOL-PRIORITY-RULES.md</files>
  <action>Add quick reference card to TOOL-PRIORITY-RULES.md:

1. Create quick reference section:
   - File ops: Use desktop-commander skill
   - Process ops: Use desktop-commander skill
   - Code search: Use mcp__code-index-mcp__search_code_advanced
   - File search: Use mcp__code-index-mcp__find_files
   - Symbols: Use mcp__code-index-mcp__get_symbol_body
   - Relationships: Use CG at neo4j://localhost:7687
   - Thinking: Use sequential-thinking/tractatus-thinking skills
2. Format as quick lookup table
3. Include links to detailed sections

Quick reference enables rapid tool selection.</action>
  <verify>TOOL-PRIORITY-RULES.md has quick reference card with common operations and recommended tools</verify>
  <done>Quick reference card added</done>
</task>

<task type="auto">
  <name>Task 9: Update plan template with tool_priority section</name>
  <files>.planning/templates/plan-template.md</files>
  <action>Update plan template to include tool_priority guidance:

1. Read existing plan-template.md (if exists)
2. Add or update <tool_priority> section:
   - Tool selection hierarchy (Skills > MCP > Native)
   - Quick reference for common operations
   - Link to TOOL-PRIORITY-RULES.md
   - Examples of correct tool usage
3. Ensure template guides plan authors toward MCP tools

Template ensures all future plans follow tool priority rules.</action>
  <verify>plan-template.md has tool_priority section with Skills > MCP > Native guidance</verify>
  <done>Plan template updated with tool priority guidance</done>
</task>

<task type="auto">
  <name>Task 10: Verify execute-plan.md enforces MCP requirements</name>
  <files>workflows/execute-plan.md</files>
  <action>Verify execute-plan.md has MCP tool requirements:

1. Read workflows/execute-plan.md
2. Check for <tool_requirements> section
3. Verify it includes:
   - Reference to mcp__desktop-commander__* for file operations
   - Reference to mcp__code-index-mcp__* for code search
   - Reference to CG for relationship analysis
   - Skills > MCP > Native hierarchy
4. If missing, add the section
5. If incomplete, enhance with CG references

execute-plan.md is the main workflow that spawns agents, so it must enforce tool requirements.</action>
  <verify>execute-plan.md has comprehensive tool_requirements section enforcing MCP usage for all 3 servers</verify>
  <done>execute-plan.md verified/enhanced with MCP tool requirements</done>
</task>

</tasks>

<verification>
1. TOOL-PRIORITY-RULES.md exists with comprehensive hierarchy (Skills > DC MCP > Other MCP > Native)
2. All 3 MCP servers (DC, CI, CG) integrated into priority rules
3. Tool selection matrix provides quick reference
4. Batching and optimization guidelines documented
5. Enforcement and compliance tracking defined
6. Plan template includes tool_priority guidance
7. execute-plan.md enforces MCP tool requirements
8. Quick reference card enables rapid tool selection
</verification>

<success_criteria>
1. TOOL-PRIORITY-RULES.md complete with 150+ lines
2. All 3 MCP servers (DC, CI, CG) integrated
3. Token efficiency (80-90%) documented as justification
4. Plan template has tool_priority section
5. execute-plan.md enforces MCP requirements
6. Quick reference for common operations
7. Decision tree for optimal tool selection
</success_criteria>

<output>
After completion, create `.planning/phases/01-mcp-foundation/01-03-SUMMARY.md` with:
- Duration metrics
- All 10 task commits
- Tool priority rules established
- All 3 MCP servers integrated
- Plan template updated
- execute-plan.md verified
- Files created/modified
- Phase 1 complete with all 3 servers operational
</output>
