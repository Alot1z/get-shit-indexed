---
phase: 24
plan: 04
name: Skip Rules Implementation
type: foundation
wave: 2
depends_on: ["24-01", "24-02"]
files_modified:
  - lib/prompt-enhancer/skip-rules.js
  - lib/prompt-enhancer/index.js
autonomous: true
must_haves:
  truths:
    - "Single-word prompts are automatically skipped"
    - "Code snippets are not enhanced"
    - "URLs are passed through unchanged"
    - "Follow-up messages are context-aware"
    - "Skip rules are configurable"
  artifacts:
    - path: lib/prompt-enhancer/skip-rules.js
      min_lines: 100
      contains: ["shouldSkip", "SKIP_PATTERNS", "detectFollowUp", "isCodeSnippet"]
  key_links:
    - from: skip-rules.js
      to: mode-selector.js
      via: "skip decision"
      pattern: "returns { skip: true, reason: '...' }"
---

# Phase 24-04: Skip Rules Implementation

<objective>
Implement intelligent skip rules that detect prompts that should not be enhanced, reducing unnecessary processing and improving user experience.

**Output:** `lib/prompt-enhancer/skip-rules.js` with comprehensive skip detection.
</objective>

<execution_context>
@references/mcp-tool-reference.md
@references/ui-brand.md
</execution_context>

<context>
Phase: 24 (Prompt Enhancement Foundation)
Depends on: 24-01 (Risk Assessment), 24-02 (Mode Selector)

**Skip Categories:**
- Single words: "continue", "yes", "done", "ok"
- Code snippets: Content wrapped in ```
- URLs: https://... links
- Follow-ups: Simple responses in conversation flow
- Flags: --no-enhance explicit bypass

@.planning/STATE.md
</context>

<tasks>

## Task 1: Define Skip Patterns

**Files:** lib/prompt-enhancer/skip-rules.js

**Action:**
```javascript
// Skip Rules Implementation
// Detects prompts that should not be enhanced

// Single-word prompts to always skip
const SINGLE_WORD_SKIPS = new Set([
  'continue', 'yes', 'no', 'ok', 'okay', 'done', 'sure',
  'proceed', 'go', 'next', 'skip', 'pass', 'fine', 'good',
  'right', 'correct', 'exactly', 'agreed', 'understood',
  'y', 'n', 'yea', 'yeah', 'yep', 'nope', 'nah'
]);

// Regex patterns for skip detection
const SKIP_PATTERNS = [
  // Empty or whitespace only
  { pattern: /^\s*$/, reason: 'empty', priority: 1 },
  
  // Single word
  { pattern: /^\w{1,20}$/, reason: 'single-word', priority: 2 },
  
  // URL only
  { pattern: /^https?:\/\/[^\s]+$/i, reason: 'url-only', priority: 3 },
  
  // Code block only (entire message is code)
  { pattern: /^```[\s\S]*```$/, reason: 'code-block-only', priority: 4 },
  
  // File path only
  { pattern: /^[\w./\\-]+\.(js|ts|py|md|json|yaml|yml)$/i, reason: 'file-path', priority: 5 },
  
  // Number only
  { pattern: /^\d+$/, reason: 'number-only', priority: 6 }
];

// Follow-up indicators (lower priority, context-dependent)
const FOLLOW_UP_PATTERNS = [
  /^ok[,.]?\s*/i,
  /^got it[,.]?\s*/i,
  /^understood[,.]?\s*/i,
  /^thanks?($|[,.])/i,
  /^great[,.]?\s*/i,
  /^perfect[,.]?\s*/i,
  /^sounds good/i,
  /^that works/i
];

module.exports = { SINGLE_WORD_SKIPS, SKIP_PATTERNS, FOLLOW_UP_PATTERNS };
```

**Verify:** Patterns compile without errors

**Done:** Skip patterns defined

---

## Task 2: Implement Skip Detection

**Files:** lib/prompt-enhancer/skip-rules.js

**Action:**
```javascript
/**
 * Check if prompt should be skipped
 * @param {string} prompt - User prompt
 * @param {object} context - Additional context
 * @returns {object} { skip: boolean, reason: string, confidence: number }
 */
function shouldSkip(prompt, context = {}) {
  // Check for explicit skip flag
  if (context.forceSkip || prompt.includes('--no-enhance')) {
    return { skip: true, reason: 'explicit-flag', confidence: 1.0 };
  }
  
  // Empty check
  if (!prompt || typeof prompt !== 'string') {
    return { skip: true, reason: 'invalid-input', confidence: 1.0 };
  }
  
  const trimmed = prompt.trim();
  
  // Check single-word skips
  const lowerPrompt = trimmed.toLowerCase();
  if (SINGLE_WORD_SKIPS.has(lowerPrompt)) {
    return { skip: true, reason: 'single-word', confidence: 1.0 };
  }
  
  // Check patterns by priority
  const sortedPatterns = [...SKIP_PATTERNS].sort((a, b) => a.priority - b.priority);
  for (const { pattern, reason } of sortedPatterns) {
    if (pattern.test(trimmed)) {
      return { skip: true, reason, confidence: 0.95 };
    }
  }
  
  // Check follow-up patterns (lower confidence)
  for (const pattern of FOLLOW_UP_PATTERNS) {
    if (pattern.test(trimmed)) {
      return { 
        skip: context.conversationLength > 3, // Only skip in long conversations
        reason: 'follow-up', 
        confidence: 0.7 
      };
    }
  }
  
  // No skip detected
  return { skip: false, reason: null, confidence: 1.0 };
}

module.exports = { shouldSkip };
```

**Verify:** `shouldSkip("continue")` returns `{ skip: true, reason: 'single-word' }`

**Done:** Skip detection implemented

---

## Task 3: Implement Code Snippet Detection

**Files:** lib/prompt-enhancer/skip-rules.js

**Action:**
```javascript
/**
 * Check if prompt is primarily code
 * @param {string} prompt - User prompt
 * @returns {object} { isCode: boolean, codeRatio: number, language: string }
 */
function detectCodeSnippet(prompt) {
  const lines = prompt.split('\n');
  let codeLines = 0;
  let inCodeBlock = false;
  let detectedLanguage = null;
  
  for (const line of lines) {
    // Check for code block markers
    if (line.startsWith('```')) {
      inCodeBlock = !inCodeBlock;
      if (!inCodeBlock === false) {
        // Extract language from opening marker
        const match = line.match(/```(\w+)?/);
        if (match && match[1]) {
          detectedLanguage = match[1];
        }
      }
      continue;
    }
    
    if (inCodeBlock) {
      codeLines++;
      continue;
    }
    
    // Check for inline code patterns
    if (line.includes('function ') || 
        line.includes('const ') ||
        line.includes('import ') ||
        line.includes('export ') ||
        line.includes('return ') ||
        line.includes('class ') ||
        /^[{\[\(]/.test(line.trim())) {
      codeLines++;
    }
  }
  
  const codeRatio = codeLines / lines.length;
  
  return {
    isCode: codeRatio > 0.7,
    codeRatio,
    language: detectedLanguage
  };
}

/**
 * Check if prompt is a URL
 * @param {string} prompt - User prompt
 * @returns {object} { isUrl: boolean, url: string }
 */
function detectUrl(prompt) {
  const trimmed = prompt.trim();
  const urlPattern = /^https?:\/\/[^\s]+$/i;
  
  if (urlPattern.test(trimmed)) {
    return { isUrl: true, url: trimmed };
  }
  
  // Check for URL in text
  const urlMatch = trimmed.match(/https?:\/\/[^\s]+/i);
  if (urlMatch) {
    return { isUrl: false, containsUrl: true, url: urlMatch[0] };
  }
  
  return { isUrl: false, url: null };
}

module.exports = { detectCodeSnippet, detectUrl };
```

**Verify:** Code detection works for various formats

**Done:** Code and URL detection implemented

---

## Task 4: Implement Follow-Up Detection

**Files:** lib/prompt-enhancer/skip-rules.js

**Action:**
```javascript
/**
 * Detect if prompt is a follow-up response
 * @param {string} prompt - User prompt
 * @param {object} conversationContext - Conversation state
 * @returns {object} { isFollowUp: boolean, type: string }
 */
function detectFollowUp(prompt, conversationContext = {}) {
  const trimmed = prompt.trim().toLowerCase();
  const { lastEnhanced, turnCount = 0 } = conversationContext;
  
  // Short acknowledgment
  if (trimmed.length < 10 && /^(ok|yes|no|sure|done|got it|thanks?)/i.test(trimmed)) {
    return { isFollowUp: true, type: 'acknowledgment' };
  }
  
  // Agreement patterns
  if (/^(sounds good|that works|perfect|great|agreed|exactly)/i.test(trimmed)) {
    return { isFollowUp: true, type: 'agreement' };
  }
  
  // Continuation requests
  if (/^(continue|keep going|next|proceed|go ahead)/i.test(trimmed)) {
    return { isFollowUp: true, type: 'continuation' };
  }
  
  // Simple questions that don't need enhancement
  if (/^(what|why|how|when|where)\s+(about|else|now)\??$/i.test(trimmed)) {
    return { isFollowUp: true, type: 'simple-question' };
  }
  
  // Context: recently enhanced, likely follow-up
  if (lastEnhanced && turnCount < 3) {
    if (trimmed.length < 20) {
      return { isFollowUp: true, type: 'short-response', confidence: 0.6 };
    }
  }
  
  return { isFollowUp: false, type: null };
}

/**
 * Get skip decision based on multiple factors
 * @param {string} prompt - User prompt
 * @param {object} context - Full context
 * @returns {object} Skip decision with reasoning
 */
function getSkipDecision(prompt, context = {}) {
  // Basic skip check
  const basicSkip = shouldSkip(prompt, context);
  if (basicSkip.skip && basicSkip.confidence > 0.8) {
    return basicSkip;
  }
  
  // Code detection
  const codeResult = detectCodeSnippet(prompt);
  if (codeResult.isCode) {
    return { 
      skip: true, 
      reason: 'code-snippet', 
      confidence: 0.9,
      metadata: { language: codeResult.language }
    };
  }
  
  // URL detection
  const urlResult = detectUrl(prompt);
  if (urlResult.isUrl) {
    return { skip: true, reason: 'url-only', confidence: 1.0 };
  }
  
  // Follow-up detection (context-dependent)
  const followUpResult = detectFollowUp(prompt, context);
  if (followUpResult.isFollowUp && context.conversationLength > 3) {
    return { 
      skip: true, 
      reason: `follow-up-${followUpResult.type}`, 
      confidence: 0.7 
    };
  }
  
  // Combine with basic skip (lower confidence)
  if (basicSkip.skip) {
    return basicSkip;
  }
  
  return { skip: false, reason: null, confidence: 1.0 };
}

module.exports = { detectFollowUp, getSkipDecision };
```

**Verify:** Follow-up detection works correctly

**Done:** Follow-up detection implemented

---

## Task 5: Add Configuration Support

**Files:** lib/prompt-enhancer/skip-rules.js

**Action:**
```javascript
/**
 * Default skip configuration
 */
const DEFAULT_CONFIG = {
  skipSingleWords: true,
  skipCodeSnippets: true,
  skipUrls: true,
  skipFollowUps: true,
  followUpThreshold: 3, // Conversation turns before skipping follow-ups
  codeRatioThreshold: 0.7,
  customSkipWords: [],
  customSkipPatterns: []
};

let currentConfig = { ...DEFAULT_CONFIG };

/**
 * Configure skip rules
 * @param {object} config - Configuration options
 */
function configureSkipRules(config = {}) {
  currentConfig = {
    ...DEFAULT_CONFIG,
    ...config,
    // Merge custom words/patterns
    customSkipWords: [...DEFAULT_CONFIG.customSkipWords, ...(config.customSkipWords || [])],
    customSkipPatterns: [...DEFAULT_CONFIG.customSkipPatterns, ...(config.customSkipPatterns || [])]
  };
}

/**
 * Get current configuration
 * @returns {object} Current skip configuration
 */
function getSkipConfig() {
  return { ...currentConfig };
}

/**
 * Add custom skip word
 * @param {string} word - Word to skip
 */
function addSkipWord(word) {
  const lower = word.toLowerCase();
  if (!SINGLE_WORD_SKIPS.has(lower)) {
    SINGLE_WORD_SKIPS.add(lower);
    currentConfig.customSkipWords.push(lower);
  }
}

/**
 * Add custom skip pattern
 * @param {RegExp} pattern - Pattern to skip
 * @param {string} reason - Reason for skip
 */
function addSkipPattern(pattern, reason) {
  SKIP_PATTERNS.push({ pattern, reason, priority: 99 });
  currentConfig.customSkipPatterns.push({ pattern: pattern.source, reason });
}

module.exports = { 
  configureSkipRules, 
  getSkipConfig, 
  addSkipWord, 
  addSkipPattern,
  DEFAULT_CONFIG 
};
```

**Verify:** Configuration functions work correctly

**Done:** Configuration support implemented

</tasks>

<verification>
- [ ] shouldSkip() detects all skip categories
- [ ] detectCodeSnippet() identifies code blocks
- [ ] detectUrl() identifies URL-only prompts
- [ ] detectFollowUp() identifies conversation follow-ups
- [ ] getSkipDecision() combines all checks
- [ ] Configuration is customizable
</verification>

<success_criteria>
- [ ] Single-word prompts are automatically skipped
- [ ] Code snippets are not enhanced
- [ ] URLs are passed through unchanged
- [ ] Follow-up messages are context-aware
- [ ] Skip rules are configurable
</success_criteria>

<output>
**Files Modified:**
- lib/prompt-enhancer/skip-rules.js (~200 lines)
- lib/prompt-enhancer/index.js (updated exports)

**Total:** ~200 lines of code
</output>
