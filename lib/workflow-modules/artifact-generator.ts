/**
 * GSI Artifact Generator Module - Phase 49-F Integration
 *
 * Generates multiple artifact types from extracted patterns:
 * - Skills: Claude Code skills for reuse
 * - Agents: GSI agent definitions
 * - Logic: TypeScript functions/logic modules
 * - Functions: Reusable function implementations
 * - Features: Feature specifications
 * - Improvements: Command enhancement suggestions
 * - Ideas: Visionary concepts and proposals
 */

import { writeFileSync, mkdirSync, existsSync } from 'fs';
import { join, basename } from 'path';
import { KnowledgePattern, PatternCategory } from './knowledge-base.js';

// Artifact Type System
export type ArtifactType = 
  | 'SKILL' 
  | 'AGENT' 
  | 'LOGIC' 
  | 'FUNCTION' 
  | 'FEATURE' 
  | 'IMPROVEMENT' 
  | 'IDEA';

export interface GeneratedArtifact {
  type: ArtifactType;
  id: string;
  name: string;
  description: string;
  source_pattern: string;
  content: string;
  file_path: string;
  created_at: string;
  metadata: ArtifactMetadata;
}

export interface ArtifactMetadata {
  category: PatternCategory;
  effectiveness: number;
  tags: string[];
  dependencies: string[];
  version: string;
}

// Artifact Generator Interface
export interface ArtifactGenerator {
  type: ArtifactType;
  generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact>;
  getTemplate(pattern: KnowledgePattern): string;
  getFileName(pattern: KnowledgePattern): string;
}

/**
 * Skill Artifact Generator
 */
export class SkillGenerator implements ArtifactGenerator {
  type: ArtifactType = 'SKILL';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'skills', fileName);
    
    mkdirSync(join(outputDir, 'skills'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `skill-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: this.extractTags(pattern),
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    return `# ${pattern.name}

## Purpose
${pattern.description}

## Context
Extracted from: ${pattern.source}

## When to Use
${pattern.whenToUse.map(u => `- ${u}`).join('\n')}

## How to Apply
${pattern.howToApply.map(a => a).join('\n')}

## Variations
${pattern.variations.length > 0 
  ? pattern.variations.map(v => `### ${v.name}\n${v.description}\nContext: ${v.context}`).join('\n\n')
  : 'No variations defined.'}

## Examples
${pattern.examples.map(e => `### ${e.name}\n\`\`\`\n${e.code}\n\`\`\`\n${e.explanation}`).join('\n\n')}

## Effectiveness
${(pattern.effectiveness * 100).toFixed(0)}% (based on ${pattern.uses} uses)

## History
- Extracted: ${new Date().toISOString()}
- Source: ${pattern.source}
- Uses: ${pattern.uses}
- Generated by: GSI Artifact Generator (Phase 49-F)
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const slug = pattern.name.toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return `${slug}.md`;
  }

  private extractTags(pattern: KnowledgePattern): string[] {
    const tags = [pattern.category];
    pattern.whenToUse.forEach(u => {
      const words = u.toLowerCase().split(/\s+/);
      words.filter(w => w.length > 4).forEach(w => tags.push(w));
    });
    return [...new Set(tags)].slice(0, 10);
  }
}

/**
 * Agent Artifact Generator
 */
export class AgentGenerator implements ArtifactGenerator {
  type: ArtifactType = 'AGENT';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'agents', fileName);
    
    mkdirSync(join(outputDir, 'agents'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `agent-${pattern.id}`,
      name: this.generateAgentName(pattern),
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: this.extractTags(pattern),
        dependencies: this.inferDependencies(pattern),
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const agentName = this.generateAgentName(pattern);
    const thinkingConfig = this.inferThinkingConfig(pattern);
    
    return `---
name: ${agentName}
description: ${pattern.description}
allowed_tools:
${this.inferTools(pattern).map(t => `  - ${t}`).join('\n')}
thinking_phase:
  mode: ${thinkingConfig.mode}
  servers:
${thinkingConfig.servers.map(s => `    - ${s}`).join('\n')}
  bmad_enabled: ${thinkingConfig.bmad_enabled}
  timeout: ${thinkingConfig.timeout}
  rationale: "${thinkingConfig.rationale}"
---

# ${agentName}

## Objective
${pattern.description}

## Context
This agent was automatically generated from pattern: ${pattern.id}

Source: ${pattern.source}

## Capabilities
${pattern.whenToUse.map(u => `- ${u}`).join('\n')}

## Process

<process>
1. **Initialize**: Load context and verify requirements
${pattern.howToApply.map((a, i) => `${i + 2}. **${this.stepName(a)}**: ${a}`).join('\n')}
${pattern.howToApply.length + 3}. **Complete**: Report results and update tracking
</process>

## Pattern Application

### When to Apply
${pattern.whenToUse.map(u => `- ${u}`).join('\n')}

### How to Apply
${pattern.howToApply.map(a => `- ${a}`).join('\n')}

## Examples
${pattern.examples.length > 0 
  ? pattern.examples.map(e => `### ${e.name}\n\`\`\`\n${e.code}\n\`\`\`\n${e.explanation}`).join('\n\n')
  : 'No examples available.'}

## Notes
- Effectiveness: ${(pattern.effectiveness * 100).toFixed(0)}%
- Uses: ${pattern.uses}
- Generated: ${new Date().toISOString()}

<!--
Generated by GSI Artifact Generator (Phase 49-F)
Pattern Source: ${pattern.source}
-->
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const slug = this.generateAgentName(pattern).toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return `gsi-${slug}.md`;
  }

  private generateAgentName(pattern: KnowledgePattern): string {
    const words = pattern.name.replace(/Pattern/i, '').trim().split(/\s+/);
    const keyWords = words.filter(w => w.length > 3).slice(0, 3);
    return keyWords.join(' ');
  }

  private inferTools(pattern: KnowledgePattern): string[] {
    const baseTools = ['mcp__desktop-commander__read_file', 'mcp__desktop-commander__write_file'];
    const categoryTools: Record<PatternCategory, string[]> = {
      'command-patterns': ['mcp__desktop-commander__start_process', 'mcp__desktop-commander__list_directory'],
      'thinking-configs': ['mcp__sequential-thinking__sequentialthinking'],
      'workflows': ['mcp__desktop-commander__*', 'mcp__code-index-mcp__*'],
      'agents': ['Task', 'mcp__desktop-commander__*'],
      'error-handling': ['mcp__debug-thinking__debug_thinking', 'mcp__desktop-commander__*'],
      'optimization': ['mcp__code-index-mcp__search_code_advanced', 'mcp__desktop-commander__*']
    };
    return [...new Set([...baseTools, ...(categoryTools[pattern.category] || [])])];
  }

  private inferThinkingConfig(pattern: KnowledgePattern): {
    mode: string;
    servers: string[];
    bmad_enabled: boolean;
    timeout: number;
    rationale: string;
  } {
    const complexity = this.assessComplexity(pattern);
    
    if (complexity === 'high') {
      return {
        mode: 'COMPREHENSIVE',
        servers: ['sequential', 'tractatus', 'debug'],
        bmad_enabled: true,
        timeout: 180000,
        rationale: 'High complexity pattern requires comprehensive analysis'
      };
    } else if (complexity === 'medium') {
      return {
        mode: 'STANDARD',
        servers: ['sequential', 'tractatus'],
        bmad_enabled: true,
        timeout: 120000,
        rationale: 'Medium complexity pattern benefits from structured thinking'
      };
    } else {
      return {
        mode: 'LIGHTWEIGHT',
        servers: ['sequential'],
        bmad_enabled: false,
        timeout: 60000,
        rationale: 'Low complexity pattern requires minimal cognitive enhancement'
      };
    }
  }

  private assessComplexity(pattern: KnowledgePattern): 'high' | 'medium' | 'low' {
    const factors = {
      steps: pattern.howToApply.length,
      variations: pattern.variations.length,
      examples: pattern.examples.length,
      uses: pattern.uses
    };
    
    const score = factors.steps * 2 + factors.variations + factors.examples + Math.min(factors.uses, 10);
    
    if (score > 15) return 'high';
    if (score > 8) return 'medium';
    return 'low';
  }

  private stepName(step: string): string {
    const match = step.match(/^\d+\.\s*(?:\*\*)?([^:*]+)(?:\*\*)?/);
    return match ? match[1].trim() : 'Process';
  }

  private extractTags(pattern: KnowledgePattern): string[] {
    return [pattern.category, 'auto-generated', 'gsi-agent'];
  }

  private inferDependencies(pattern: KnowledgePattern): string[] {
    const deps: Record<PatternCategory, string[]> = {
      'command-patterns': ['gsi-tools.js'],
      'thinking-configs': ['thinking-orchestrator'],
      'workflows': ['workflow-chainer', 'gsi-tools.js'],
      'agents': ['gsi-tools.js'],
      'error-handling': ['reflection-capture'],
      'optimization': ['pattern-learning']
    };
    return deps[pattern.category] || [];
  }
}

/**
 * Logic Artifact Generator
 */
export class LogicGenerator implements ArtifactGenerator {
  type: ArtifactType = 'LOGIC';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'logic', fileName);
    
    mkdirSync(join(outputDir, 'logic'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `logic-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['typescript', 'logic', pattern.category],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const moduleName = this.generateModuleName(pattern);
    
    return `/**
 * ${pattern.name}
 * 
 * ${pattern.description}
 * 
 * @module ${moduleName}
 * @generated ${new Date().toISOString()}
 * @pattern ${pattern.id}
 */

export interface ${this.interfaceName(pattern)}Context {
  input: any;
  options?: Record<string, any>;
}

export interface ${this.interfaceName(pattern)}Result {
  success: boolean;
  data?: any;
  error?: string;
}

export async function ${this.functionName(pattern)}(
  context: ${this.interfaceName(pattern)}Context
): Promise<${this.interfaceName(pattern)}Result> {
  try {
    // Steps from pattern:
    // ${pattern.howToApply.join('\n    // ')}
    
    let result = context.input;
    
    // TODO: Implement specific logic based on pattern
    
    return { success: true, data: result };
  } catch (error) {
    return { 
      success: false, 
      error: error instanceof Error ? error.message : String(error) 
    };
  }
}

export default ${this.functionName(pattern)};
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const slug = this.generateModuleName(pattern).toLowerCase()
      .replace(/[^a-z0-9]+/g, '-')
      .replace(/^-+|-+$/g, '');
    return `${slug}.ts`;
  }

  private generateModuleName(pattern: KnowledgePattern): string {
    return pattern.name.replace(/[^a-zA-Z0-9]/g, '');
  }

  private interfaceName(pattern: KnowledgePattern): string {
    return this.generateModuleName(pattern);
  }

  private functionName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    return name.split(/\s+/).map(w => w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()).join('');
  }
}

/**
 * Function Artifact Generator
 */
export class FunctionGenerator implements ArtifactGenerator {
  type: ArtifactType = 'FUNCTION';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'functions', fileName);
    
    mkdirSync(join(outputDir, 'functions'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `function-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['typescript', 'function', 'reusable'],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const functionName = this.generateFunctionName(pattern);
    
    return `/**
 * ${pattern.name}
 * 
 * ${pattern.description}
 * 
 * @param input - Input data
 * @param options - Optional configuration
 * @returns Processed result
 * 
 * @pattern ${pattern.id}
 * @generated ${new Date().toISOString()}
 */

export function ${functionName}(
  input: any,
  options?: { verbose?: boolean; timeout?: number }
): any {
  const opts = { verbose: false, timeout: 30000, ...options };

  try {
    // Implementation steps:
    // ${pattern.howToApply.join('\n    // ')}
    
    let result = input;
    
    // TODO: Implement specific function logic
    
    return result;
  } catch (error) {
    if (opts.verbose) {
      console.error('[${functionName}] Error:', error);
    }
    throw error;
  }
}

export default ${functionName};
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = this.generateFunctionName(pattern);
    return `${name}.ts`;
  }

  private generateFunctionName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    return name.split(/\s+/).map((w, i) => 
      i === 0 ? w.toLowerCase() : w.charAt(0).toUpperCase() + w.slice(1).toLowerCase()
    ).join('');
  }
}

/**
 * Feature Artifact Generator
 */
export class FeatureGenerator implements ArtifactGenerator {
  type: ArtifactType = 'FEATURE';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'features', fileName);
    
    mkdirSync(join(outputDir, 'features'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `feature-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['feature', 'specification', pattern.category],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    const featureName = pattern.name.replace(/Pattern/i, 'Feature').trim();
    
    return `# ${featureName}

## Overview

**Pattern ID**: ${pattern.id}
**Source**: ${pattern.source}
**Effectiveness**: ${(pattern.effectiveness * 100).toFixed(0)}%
**Generated**: ${new Date().toISOString()}

${pattern.description}

## Use Cases

${pattern.whenToUse.map((u, i) => `${i + 1}. ${u}`).join('\n')}

## Specification

### Functional Requirements

${pattern.howToApply.map((a, i) => `#### FR-${String(i + 1).padStart(2, '0')}: ${a}`).join('\n\n')}

## Implementation Plan

${pattern.howToApply.map((a, i) => `${i + 1}. ${a}`).join('\n')}

## Examples

${pattern.examples.length > 0 
  ? pattern.examples.map(e => `### ${e.name}\n\`\`\`\n${e.code}\n\`\`\`\n${e.explanation}`).join('\n\n')
  : 'No examples available.'}

## Metrics

| Metric | Value |
|--------|-------|
| Effectiveness | ${(pattern.effectiveness * 100).toFixed(0)}% |
| Uses | ${pattern.uses} |
| Steps | ${pattern.howToApply.length} |

---
*Generated by GSI Artifact Generator (Phase 49-F)*
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return `${slug}-feature.md`;
  }
}

/**
 * Improvement Artifact Generator
 */
export class ImprovementGenerator implements ArtifactGenerator {
  type: ArtifactType = 'IMPROVEMENT';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'improvements', fileName);
    
    mkdirSync(join(outputDir, 'improvements'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `improvement-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['improvement', 'enhancement', 'suggestion'],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    return `# Improvement Suggestion: ${pattern.name}

## Overview

**Pattern ID**: ${pattern.id}
**Source**: ${pattern.source}
**Generated**: ${new Date().toISOString()}

## Analysis

### Current State
${pattern.description}

### Metrics
- **Effectiveness**: ${(pattern.effectiveness * 100).toFixed(0)}%
- **Uses**: ${pattern.uses}

## Suggested Improvements

### High Priority: Improve Effectiveness
${pattern.effectiveness < 0.8 ? `
**Rationale**: Current effectiveness of ${(pattern.effectiveness * 100).toFixed(0)}% indicates room for improvement

**Implementation**:
1. Analyze failure cases
2. Identify common issues
3. Refine pattern logic

**Expected Impact**: Could improve success rate by 20-30%
` : 'Pattern already has high effectiveness'}

### Medium Priority: Expand Documentation
${pattern.examples.length < 2 ? `
**Rationale**: Limited examples may hinder adoption

**Implementation**:
1. Document common use cases
2. Add edge case examples
3. Include error handling examples
` : 'Pattern has sufficient examples'}

## Implementation Roadmap

### Short-term (1-2 weeks)
- [ ] Review failure cases
- [ ] Add documentation

### Medium-term (1 month)
- [ ] Implement improvements
- [ ] Add variations

---
*Generated by GSI Artifact Generator (Phase 49-F)*
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return `${slug}-improvement.md`;
  }
}

/**
 * Idea Artifact Generator
 */
export class IdeaGenerator implements ArtifactGenerator {
  type: ArtifactType = 'IDEA';

  async generate(pattern: KnowledgePattern, outputDir: string): Promise<GeneratedArtifact> {
    const content = this.getTemplate(pattern);
    const fileName = this.getFileName(pattern);
    const filePath = join(outputDir, 'ideas', fileName);
    
    mkdirSync(join(outputDir, 'ideas'), { recursive: true });
    writeFileSync(filePath, content);
    
    return {
      type: this.type,
      id: `idea-${pattern.id}`,
      name: pattern.name,
      description: pattern.description,
      source_pattern: pattern.id,
      content,
      file_path: filePath,
      created_at: new Date().toISOString(),
      metadata: {
        category: pattern.category,
        effectiveness: pattern.effectiveness,
        tags: ['idea', 'vision', 'concept'],
        dependencies: [],
        version: '1.0.0'
      }
    };
  }

  getTemplate(pattern: KnowledgePattern): string {
    return `# Visionary Idea: ${pattern.name}

## Concept Overview

**Pattern ID**: ${pattern.id}
**Source**: ${pattern.source}
**Generated**: ${new Date().toISOString()}

## Origin Pattern

${pattern.description}

**Metrics**:
- Effectiveness: ${(pattern.effectiveness * 100).toFixed(0)}%
- Uses: ${pattern.uses}
- Category: ${pattern.category}

---

## Generated Ideas

### Idea 1: Pattern-Driven Automation

**Vision**: Automate repetitive tasks by recognizing and applying patterns

**Description**: Build a system that recognizes when patterns from ${pattern.category} can be applied automatically, reducing manual intervention.

**Potential Impact**: Could reduce manual work by 50% for common tasks

**Feasibility**: High - Pattern data already exists

**Next Steps**:
1. Identify automation candidates
2. Build pattern matching system
3. Create automation pipeline
4. Add human review for edge cases

### Idea 2: Cross-Pattern Synergy

**Vision**: Discover new best practices by combining patterns

**Description**: Analyze how ${pattern.name} can be combined with other patterns to create more effective solutions.

**Potential Impact**: May discover novel approaches not obvious from individual patterns

**Feasibility**: Medium - Requires pattern relationship analysis

## Research Questions

1. How can ${pattern.category} patterns be combined for maximum effectiveness?
2. What metrics best predict pattern success in different contexts?
3. Can pattern effectiveness be improved through automated refinement?

---
*Generated by GSI Artifact Generator (Phase 49-F)*
`;
  }

  getFileName(pattern: KnowledgePattern): string {
    const name = pattern.name.replace(/Pattern/i, '').trim();
    const slug = name.toLowerCase().replace(/[^a-z0-9]+/g, '-').replace(/^-+|-+$/g, '');
    return `${slug}-idea.md`;
  }
}

/**
 * Master Artifact Generator
 * Coordinates all artifact type generators
 */
export class ArtifactGeneratorManager {
  private generators: Map<ArtifactType, ArtifactGenerator>;
  private outputDir: string;

  constructor(outputDir: string) {
    this.outputDir = outputDir;
    this.generators = new Map([
      ['SKILL', new SkillGenerator()],
      ['AGENT', new AgentGenerator()],
      ['LOGIC', new LogicGenerator()],
      ['FUNCTION', new FunctionGenerator()],
      ['FEATURE', new FeatureGenerator()],
      ['IMPROVEMENT', new ImprovementGenerator()],
      ['IDEA', new IdeaGenerator()]
    ]);
  }

  async generate(pattern: KnowledgePattern, type: ArtifactType): Promise<GeneratedArtifact> {
    const generator = this.generators.get(type);
    if (!generator) {
      throw new Error(`Unknown artifact type: ${type}`);
    }
    return generator.generate(pattern, this.outputDir);
  }

  async generateAll(pattern: KnowledgePattern): Promise<GeneratedArtifact[]> {
    const artifacts: GeneratedArtifact[] = [];
    const types: ArtifactType[] = ['SKILL', 'AGENT', 'LOGIC', 'FUNCTION', 'FEATURE', 'IMPROVEMENT', 'IDEA'];
    
    for (const type of types) {
      try {
        const artifact = await this.generate(pattern, type);
        artifacts.push(artifact);
      } catch (error) {
        console.error(`Failed to generate ${type} for pattern ${pattern.id}:`, error);
      }
    }
    
    return artifacts;
  }

  async generateTypes(pattern: KnowledgePattern, types: ArtifactType[]): Promise<GeneratedArtifact[]> {
    const artifacts: GeneratedArtifact[] = [];
    
    for (const type of types) {
      try {
        const artifact = await this.generate(pattern, type);
        artifacts.push(artifact);
      } catch (error) {
        console.error(`Failed to generate ${type} for pattern ${pattern.id}:`, error);
      }
    }
    
    return artifacts;
  }

  getAvailableTypes(): ArtifactType[] {
    return Array.from(this.generators.keys());
  }

  getGenerator(type: ArtifactType): ArtifactGenerator | undefined {
    return this.generators.get(type);
  }
}

export default ArtifactGeneratorManager;
