// Layer 3: Auto-Split Decision Engine
// Automatically splits high-complexity plans into manageable sub-phases

const { getModelThresholds } = require('./model-awareness.js');
const fs = require('fs').promises;
const path = require('path');

/**
 * Calculate how many sub-phases are needed based on complexity score.
 * Uses model-specific thresholds from Layer 1.
 *
 * @param {number} score - The complexity score (0-100 scale)
 * @returns {Promise<number>} Number of sub-phases needed (1 = no split)
 */
async function calculateSubPhaseCount(score) {
  const thresholds = await getModelThresholds();
  
  if (score <= thresholds.split_threshold) {
    return 1; // No split needed
  }
  
  // Calculate how many sub-phases needed
  const subPhaseCount = Math.ceil(score / thresholds.split_threshold);
  
  // Cap at reasonable maximum (avoid over-fragmentation)
  const maxSubPhases = 5;
  return Math.min(subPhaseCount, maxSubPhases);
}

/**
 * Split a plan into multiple sub-phases.
 * Distributes tasks evenly across sub-phases.
 *
 * @param {string} planContent - The full plan content as string
 * @param {number} subPhaseCount - Number of sub-phases to create
 * @returns {Promise<object>} Split result with originalTaskCount, subPhaseCount, subPhases array
 */
async function splitPlan(planContent, subPhaseCount) {
  // Parse tasks from plan content
  const taskMatches = [...planContent.matchAll(/<task[^>]*>([\s\S]*?)<\/task>/g)];
  const tasks = taskMatches.map((m, i) => ({
    index: i,
    content: m[0],
    fullMatch: m[0]
  }));
  
  // Distribute tasks across sub-phases
  const tasksPerPhase = Math.ceil(tasks.length / subPhaseCount);
  const subPhases = [];
  
  for (let i = 0; i < subPhaseCount; i++) {
    const start = i * tasksPerPhase;
    const end = Math.min(start + tasksPerPhase, tasks.length);
    subPhases.push({
      phaseNumber: i + 1,
      tasks: tasks.slice(start, end),
      taskCount: end - start
    });
  }
  
  return {
    originalTaskCount: tasks.length,
    subPhaseCount,
    subPhases
  };
}

/**
 * Generate sub-phase plan content from original plan.
 *
 * @param {object} subPhase - Sub-phase object with phaseNumber and tasks
 * @param {string} originalContent - Original plan content
 * @returns {string} Generated sub-phase plan content
 */
function generateSubPlanContent(subPhase, originalContent) {
  // Extract frontmatter from original
  const frontmatter = originalContent.match(/^---[\s\S]*?---/)?.[0] || '';
  
  return `${frontmatter}

# Auto-Split Sub-Phase ${subPhase.phaseNumber}

This plan was automatically generated by the Complexity Prediction System.

## Tasks (${subPhase.taskCount})

${subPhase.tasks.map(t => t.content).join('\n\n')}
`;
}

/**
 * Execute auto-split on a plan.
 * Creates sub-phase plan files when score exceeds threshold.
 *
 * @param {string} planPath - Path to the original plan file
 * @param {number} score - Complexity score
 * @param {object} options - Options object
 * @param {boolean} options.yoloMode - If true, skip confirmation and auto-split
 * @returns {Promise<object>} Split result with split flag and generated plan paths
 */
async function executeAutoSplit(planPath, score, options = {}) {
  const subPhaseCount = await calculateSubPhaseCount(score);
  
  if (subPhaseCount === 1) {
    return { split: false, reason: "Score below split threshold" };
  }
  
  // YOLO mode: Auto-split without confirmation
  if (options.yoloMode) {
    console.log(`[YOLO MODE] Auto-splitting plan with score ${score} into ${subPhaseCount} sub-phases`);
    // Continue with split without warning user
  }
  
  // Read original plan
  const planContent = await fs.readFile(planPath, 'utf-8');
  
  // Split the plan
  const splitResult = await splitPlan(planContent, subPhaseCount);
  
  // Generate sub-phase plan files
  const generatedPlans = [];
  const basePath = planPath.replace('-PLAN.md', '');
  
  for (const subPhase of splitResult.subPhases) {
    const subPlanPath = `${basePath}-PART${subPhase.phaseNumber.toString().padStart(2, '0')}-PLAN.md`;
    
    // Create sub-phase plan content
    const subPlanContent = generateSubPlanContent(subPhase, planContent);
    
    // Write sub-phase plan
    await fs.writeFile(subPlanPath, subPlanContent, 'utf-8');
    generatedPlans.push(subPlanPath);
  }
  
  return {
    split: true,
    subPhaseCount,
    generatedPlans,
    originalTaskCount: splitResult.originalTaskCount
  };
}

module.exports = {
  calculateSubPhaseCount,
  splitPlan,
  executeAutoSplit
};
